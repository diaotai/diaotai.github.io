<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="日拱一卒">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="日拱一卒">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="日拱一卒">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>日拱一卒</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">日拱一卒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我将继续前行，不管是前路是荆棘还是坦途</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/13/python-学习笔记-基础/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/13/python-学习笔记-基础/" itemprop="url">python 学习笔记(基础)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-13T16:00:22+08:00">
                2019-07-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本笔记是我第 n 次重新上手 python 的笔记，该笔记并不全面，但是记录了很多关于 python 的某些的需要注意的点。只要注意到这些点，对我来说就可以迅速重新上手这门语言。</p>
</blockquote>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul>
<li>python 中变量不需要声明</li>
<li>python 并没有常量的概念，虽然惯例上使用大写字母作为常量名，但是这只是惯例上的约束，实际上依旧可以改变</li>
<li>整数相除必然除出浮点数，除非用 // 地板除</li>
<li>int 数字等于对应的浮点数</li>
<li>只要 x 上非零数字、非空字符串、非空 list 等，就判断为 True，否则为 False</li>
</ul>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><ul>
<li>不可越界，否则报错</li>
<li>可以存放不同的类型</li>
<li>insert(index, val) 方法用于插入, pop(index?) 可以用来删除指定位置的值</li>
</ul>
<h2 id="turple"><a href="#turple" class="headerlink" title="turple"></a>turple</h2><ul>
<li>形式类似于 (1, 3, 4),其内容是不可变的，剩下基本等同于 list</li>
</ul>
<h2 id="dic"><a href="#dic" class="headerlink" title="dic"></a>dic</h2><ul>
<li>可以用 in 来判断某个 key 是否存在于对象</li>
<li>get 方法可以用来安全的获取值，并可以在第二个参数设置默认值</li>
<li>pop 可以用来删除特定 key</li>
</ul>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ul>
<li>添加可以使用 add 方法</li>
<li>删除的方法为 remove 而不是 pop</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul>
<li>python 的函数可以返回多个值</li>
<li>python 的默认参数一定要指向不变的对象</li>
<li>参数星号代表多参数，参数会以 list 的形式插入</li>
<li>两个星号则代表以命名参数的行事形成一个 dic</li>
<li>注意，python 同样存在闭包问题，因此要考虑变量在延迟执行时的情况</li>
</ul>
<h1 id="迭代器及函数式编程"><a href="#迭代器及函数式编程" class="headerlink" title="迭代器及函数式编程"></a>迭代器及函数式编程</h1><ul>
<li>能被 for 使用的对象就是 iterable 对象</li>
<li>能调用 next 的才是 Iterator 迭代器，可以理解为一个超长的数据流</li>
<li>map, resuce, filter 的第一个参数是函数，第二个才是迭代器</li>
<li>sorted 的第一个参数是 list，第二个是 key=function，第三个是布尔值 reverse</li>
<li>functools.partial 可以以默认值的方式从右向左固定一些值</li>
</ul>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def log(func):</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure>
<ul>
<li>func 即为被装饰器所包装的函数，如果需要给装饰器添加参数，则需要再包一层，参数放在最外边</li>
</ul>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><ul>
<li>python 使用包和文件作为模块的机制，包下必须要有<strong>init</strong>.py,否则会被认为是普通的目录</li>
<li>python 没有限制导出的策略，因此习惯上正常变量名随意导出、<strong>xxx</strong>属于有特殊用途的情况，而_xxx属于私有变量，不应该被使用</li>
</ul>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Name(object)</span><br></pre></td></tr></table></figure>
<ul>
<li>类名通常大写，括号内则是继承的类名</li>
<li>__init__代表构造函数，第一个参数为 self 实例本身，后面则是类的参数</li>
<li>类内的 __xxx  在类外不可访问</li>
<li>python 在类型上属于鸭子类型语言，十分类似于 go</li>
<li>isinstance 可以判断子类及本身，而 type 则可以判断 class 类型</li>
<li>不加 self 即为类属性，实例属性会覆盖类属性，找不到实例属性就会去找类属性(直接在类中书写普通变量即可)</li>
<li>__slots__属性可以限制允许挂载到对象上的属性的</li>
<li>@property 用来将方法变成了 getter, @xxx.settter 把方法变成了赋值的 setter</li>
<li>结合 hasattr, getattr, setattr 可以很好的处理对象的属性</li>
<li>__str__代表返回给用户的字符串，__repr__代表返回给开发者的字符串</li>
<li>要想实现一个迭代器，则必须实现__iter__方法返回一个迭代对象，并实现一个__next__方法不断的调用，直到碰到 StopIteration Error </li>
<li>__getItem__可以帮助实现一个类似于 list 的结构</li>
<li>__getattr__用于处理没有定义的属性</li>
<li>__call__让一个对象可以直接作为方法来被调用</li>
</ul>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ul>
<li>测试分为单元测试和文档测试</li>
<li>class TestDict(unittest.TestCase) 可以用来测试</li>
<li>setUp() 和 tearDown() 可以在测试开始前和结束后执行</li>
</ul>
<h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><ul>
<li>namedtuple 可以实现一个类似于类的小玩意</li>
<li>dqeue 用于实现队列和栈，存在 append, pop, appendleft, popleft 方法</li>
<li>OrderedDict 会按插入的顺序进行排布</li>
<li>ChainMap 可以合并多个 dic，最后以从前向后的顺序查找值</li>
<li>struct 提供了二进制到类型的转换</li>
<li>@contextmanager 可以提供上下文，让事物在开始前结束后做一些什么东西，可用于迭代器， yield 代表了返回的值</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/17/go-语言基础汇总/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/17/go-语言基础汇总/" itemprop="url">go 语言基础汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-17T19:28:04+08:00">
                2019-06-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul>
<li>当变量声明时，类型和表达式可以省略一个。如果类型省略，则类型由表达式决定，如果省略表达式，则使用默认空值。</li>
<li>:= 表示声明，若没有该变量，则创建，若存在，则赋值。但是至少要保证创建了一个新变量，否则编译失败</li>
<li>指针的值是一个变量的地址。不是所有的值都有地址，但是所有变量都有地址。使用指针可以间接读取或更新变量的值。</li>
<li>指针是可以比较的，只有当两个指针指向同一个变量或者两者都是 nil时候，才是相等的</li>
<li>new(int) 可以直接返回一个新创建的 int 型指针</li>
<li>变量将一直生存到它不可访问，其生命周期是通过它是否可达来确定的</li>
<li>当创建的局部变量指针被赋值到全局时，即为逃逸，它会被在堆空间分配内存，否则则是栈空间分布。</li>
<li>只有类型精确匹配才可以赋值，只有两个值可以赋值时才可以比较</li>
<li>type 声明定义一个新的类型。当底层类型相同的不同的 type 使用时应当进行类型转化。</li>
</ul>
<h1 id="基本数据"><a href="#基本数据" class="headerlink" title="基本数据"></a>基本数据</h1><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><ul>
<li>rune 类型是 int32 的同义词，通常使用一个指 Unicode 码点。</li>
<li>取模的结果符号只会和被除数一致，整除相除得整数。</li>
<li>溢出得情况下会直接舍弃高位</li>
<li>&amp; 位与操作， | 位或操作， ^ 位异或操作，若为前缀，则为按位取反，&amp;^ 按位清除（z=x&amp;^y,y 某位 为 1，则 z 对应为0， 否则，为 x 的对应位）</li>
<li>和 NaN 得比较总是不成立的</li>
<li>Go 有两种类型的复数，complex64 和 complex128，二者分别由 float32 和 float64组成。</li>
<li>&amp;&amp; 的优先级比 || 更高<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2></li>
<li>字符串的第 i 个字节并不代表是第 i 个字符，因为非 ASCII 字符的 UTF-8 码点需要两个或多个字节。</li>
<li>字符串的下标越界会引发宕机</li>
<li>字符串是不可变的，这也意味着可以在底层共用同一段内存，这使得复制任何长度字符串的开销都很低廉。</li>
<li>UTF-8 以字节为单位对 Unicode 码点作变长编码。一个文字符号编码的首字节高位指出后面还有多少字节。传统 ASCII 码仅占 1 个字节。变长编码使得字符串无法直接访问第 n 个字符。</li>
<li>码点值小于 256 的文字符号可以写成单个16进制的转义形式（\xe4），更高的码点则必须\u.</li>
<li>len 得到的是字节数，真的要逐个处理 Unicode，则必须使用其他编码机制。比如 UTF-8.</li>
<li>字符串属于不可变的，如果需要，则应该使用 bytes.Buffer 对接      <h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2></li>
<li>常量只能是数字、字符串或布尔值（这个常量就是指 const）</li>
<li>对常量操作数，所有的数学运算、逻辑运算和比较结果都是常量</li>
<li>若同时声明一组常量，除了第一项之外，其余的右侧部分都可以省略，这代表值会复用前面一项的表达式及其类型</li>
<li>iota 可以从 0 开始递增</li>
</ul>
<h1 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h1><ul>
<li>数组和结构体是值传递，而 slice、map、function、channel 属于引用传递<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2></li>
<li>数组和结构体都是聚合类型，它们的值由内存中的一组变量组成。数组和结构体的长度都是固定的，slice 和 map 都是动态数据结构，它的长度在元素添加到中可以动态增长</li>
<li><p>数组是具有固定长度且拥有多个类型元素的序列，数组的长度是数组类型的一部分。长度必须是常量，这个表达式需要在程序编译时就可以确定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a [3]int</span><br><span class="line">var r [3]int = [3]int&#123;1, 2&#125;  // 初始化一部分</span><br><span class="line">q:= [...]int&#123;1,2,3&#125;   // 根据给定值确认长度</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一个数组的元素类型是可比较的，那么这个数组也是可比较的</p>
</li>
<li>数组和其它类型都是值传递,也就是说，内部修改无法影响外部，除非通过指针<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2></li>
<li>slice 可以理解为可变长度的数组，有三个属性：指针，长度和容量（指针指向原数组第一个元素，长度是元素个数，容器大小是底部数组的长度）</li>
<li>slice 的元素到过容量则会导致宕机。若 slice 引用超过长度，则最终 slice 要长过原 slice。</li>
<li>x[m:n]和字符串一样，只消耗常量时间</li>
<li>由于 slice 拥有指向数组元素的指针，所以可以在内部修改底层数组的元素</li>
<li>slice 是不能做比较的，因此也不能做 map 的 key  </li>
<li>通常将 append 的调用结果再次赋值给传入 append 函数的 slice</li>
<li><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ages := make(map[string]int)</span><br><span class="line"></span><br><span class="line">ages := map[string]int &#123;</span><br><span class="line">    &quot;abc&quot;: 332</span><br><span class="line">&#125;</span><br><span class="line">ages, ok := map[key]</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用 delete(map, key) 的操作来删除值，就算 map 中不存在 key 也没有关系</p>
</li>
<li>map 的地址不可获得，因为 map 的增长可能导致已有元素被重新放置到新的位置</li>
<li>大多数 map 操作可以用于 nil map上，但是设置值是不可以的</li>
<li>可以通过 ok 来判断 map 中是否存在</li>
<li>map 唯一的合法结构就是与 nil 比较。</li>
<li><p>map 值的类型可以为某些复杂数据结构</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Name struct &#123;</span><br><span class="line">    a      int</span><br><span class="line">    b      int</span><br><span class="line">&#125;</span><br><span class="line">P := Name&#123;1, 2&#125;         // 创建一个字面量的方法</span><br><span class="line">P := Name&#123;a:3, b: 4&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体中，成员变量的顺序对于结构体同一性来说很重要，如果顺序改变，那么就算两个不同的结构体</p>
</li>
<li>结构体成员变量如果首字母大写，那么就算可导出的。一个结构体可以同时包含可导出的成员变量和不可导出的成员变量</li>
<li>一个结构体类型不可以包含自身，但是可以包含自身的指针</li>
<li>以上两种初始化模式不可混用，此外，无法通过结构体绕过包变量导出机制</li>
<li>如果结构体中所有成员变量都可以比较，那么这个结构体就是可以比较的</li>
<li>可以通过嵌套匿名结构体的方式来为结构体增加变量，不过初始化的时候必须按照层次来</li>
<li>匿名结构体可以轻微绕过包导出机制</li>
<li>不能在结构体中放两个变量名相同的变量或匿名结构体</li>
</ul>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Movie struct &#123;</span><br><span class="line">    Title   string</span><br><span class="line">    Year    int `json:&quot;released&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只有可导出的成员变量才可以转换为 json 字段，否则会被无视。在上面的实例中，json 中的 released 字段会被解析成 Year</li>
<li>可以在 json 标注中添加 omitempty，这样如果为空则不会被输入到 JSON 中</li>
<li>JSON 在 unmarshal 阶段是无视大小写的</li>
</ul>
<h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; .abc &#125;&#125;  // 其中 abc 为变量</span><br><span class="line">通过 &#123;&#123;range .a&#125;&#125; 和 &#123;&#123;end&#125;&#125; 可以处理循环</span><br></pre></td></tr></table></figure>
<ul>
<li>通过一系列操作可以得到模版，最后通过 Execute 来得到渲染结果</li>
<li>template.HTML 会被认为是可靠的值，不会被转义</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul>
<li>函数的类型成为函数签名，当两个函数拥有相同的形参列表和返回列表时，即认为两个函数的类型或签名相同，形参和返回值的名字不影响函数类型</li>
<li>go 语言中不存在默认参数</li>
<li>如果实参中包含引用类型，比如指针、slice、map、函或者通道，那么函数使用形参变量是就有可能会间接地修改是参变量</li>
<li>go 的栈长度是可变的，最多可达到1GB的上限</li>
<li>可以返回多个值，也可以以给返回值命名的方式进行返回值</li>
<li>当函数返回非空错误时，其它所有的返回都应该被忽略</li>
<li>go 使用控制流来处理错误，当有意识的忽略某个错误时，应当以注释的形式给出原因</li>
<li>函数可以以变量的形式使用，此外函数不可比较</li>
<li>当一个匿名函数需要递归时，必须先声明一个变量然后将匿名函数赋值给这个变量</li>
<li>参数列表最后可以以 … 的形式传递任意树木的参数</li>
<li>defer 调用会在任何时候执行，具体时间是 defer 结束的时候，defer 没有次数的限制，执行时以 defer 书写的反顺序执行 </li>
<li>defer 函数可以改变返回值</li>
<li>当出现宕机时，正常的程序会停止执行，goroutine 中所有的颜值函数会执行，然后程序会退出并留下一条日志消息</li>
<li>通过内置函数 panic 可以进行宕机</li>
<li>宕机是可以恢复的，通过 recover 可以恢复，而获得的值就可以拿到 panic 的参数</li>
<li>init 函数属于普通函数，在每个文件被初始化的时候，会按照声明的顺序自动执行</li>
</ul>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ul>
<li>一个类型所拥有的方法名所唯一的，不过不同的类型可以使用相同得到方法名</li>
<li>方法调用会复制每一个实参变量，如果变量太大或者希望改变该变量，就应该传递指针。如果一个方法是指针，那么习惯上所有的方法都应该是指针</li>
<li>不允许为本身是指针的类型进行方法声明</li>
<li>编译器会对变量进行隐式的转化，不过只有变量才可以</li>
<li>如果所有类型 T 的方法的接收者都是 T（而非对应指针），那么复制它的实例是安全的，调用方法的时候都必须进行一次复制。如果是指针，那么应该尽量避免复制。</li>
<li>nil 是一个合法的指针值</li>
<li>方法的使用顺序是分层的，首先找自己存在的方法，然后是下一级的方法，然后是再下一级。如果同级有同名方法，则会报错</li>
<li>go 不支持方法的重载</li>
<li>通过调用 T.method，可以把方法再一次变成函数，这种情况下第一个值应当是T</li>
<li>go 支持封装的级别是包而不是类型，同一个包内的代码始终是可见的。</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul>
<li>接口类型是对其它类型行为的概括和抽象。通过使用接口，可以写出更为灵活和通用的函数。对于某一个类型，无需声明它都实现了哪些接口，只需要提供这些声明的方法</li>
<li>普通类型指定了所含数据的精确类型及行为，而接口只是指定了行为（也就是说，只知道实现了哪些方法）</li>
<li>当一个具体类型要实现某个接口的时候，那么必须实现接口类型中的所有方法</li>
<li>接口对于数据类型还是一种封装，变量只能调用接口里暴露的方法</li>
<li>可以把接口理解成一种分类方式，分类可以同时有多种标准</li>
<li>作为静态类型语言，类型只是编译时概念，因此不是值。给某接口类型赋值与显式转化无异</li>
<li>由于编译时无法指导一个接口值的动态类型某所以通过接口来做动态分发。编译器必须生成一段代码从接口拿到方法地址，再间接调用该地址</li>
<li>接口是可以比较的，当都为 nil 或者动态类型完全一致且二者动态值相等，那么两个接口值相等（当动态类型一致，但该类型不可比较的时候，则会崩溃）</li>
<li>空的接口值和动态类型为 nil 的值不一致，空的接口类型代表什么值都可以接收</li>
<li>在处理 sort 接口时，处理指针的代码运行速度会快很多</li>
<li>类型断言检查就算确认作为操作数的动态类型是否满足指定的断言类型，当断言类型为具体类型时，若成功，结果就为断言类型为T，失败则崩溃。当断言类型为接口类型时，则检测x的动态类型是否满足T，若成功，不做变更，结果类型变为接口类型 T</li>
<li>如果类型断言有两个值，失败也不不会崩溃</li>
<li>可以通过接口类型断言来查询特性</li>
<li>可以使用接口作为可识别联合类型某操作它的函数经常有 switch，然后对每种类型用于不同的逻辑 </li>
</ul>
<h1 id="goroutine-和通道"><a href="#goroutine-和通道" class="headerlink" title="goroutine 和通道"></a>goroutine 和通道</h1><p>goroutine 和通道（channel）支持通信顺序进程（CSP）</p>
<h2 id="goroutine-简介"><a href="#goroutine-简介" class="headerlink" title="goroutine 简介"></a>goroutine 简介</h2><ul>
<li>每一个并行执行的活动成为 goroutine。当一个程序启动时，只会有一个 goroutine 来调用 main 函数，称它为 goroutine。新的 goroutine 听过 go 语句进行创建。语法上，一个go 语句是普通的函数或方法调用前加上 go 关键字前缀的，go 语句使得函数在一个新创建的 goroutine 中调用，go 语句本身的执行立即完成。</li>
<li>除了从 main 返回或者退出程序之外，没有一个程序化的方法让一个 goroutine 停止另一个，但是可以和 goroutine 通信要求它自己停止。<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2></li>
<li>每一个通道是一个具体类型的导管，叫作通道的元素类型。一个有 int 类型元素的通道成为 chan int。</li>
<li>ch := make(chan int)  // 创建一个 int 型通道</li>
<li>ch &lt;- x 为发送语句， x = -&lt; ch 为接收语句，close 可以关闭通道。关闭通道后的发送操作会导致宕机，在一个已经关闭的通道上进行接受操作将会获取所有已经发送的值，直到通道为空，此时任何接受操作会立即完成。</li>
<li>make 可以接受第二个参数作为缓冲通道的容量大小。</li>
<li>无缓冲通道上的发送操作将会阻塞，直到另一个 goroutine 在对应的通道上执行接受操作，这时值传送完成，两个 goroutine 都可以继续执行。相反，如果接受操作先执行，接收方 goroutine 将阻塞，直到另一个 goroutine 在同一个通道上发送一个值。</li>
<li>在并发中， x 早于 y 并不是指发生的时间，而是说这个顺序是可以保证的。同样，x y 并发也不代表同时发生，只是说明不能假设其顺序。</li>
<li>并没有直接的方式来判断通道是否已关闭，但是可以通过接受到的通道元素以及 bool 型值来判断通道是否关闭并读完。</li>
<li>for range 可以在通道上迭代，保证在读完最后一个值后关闭</li>
<li>只有需要通知接收方所有数据已发送时才需要关闭通道，通道是根据是否可被访问而被决定是否回收的，而不是根据它是否被关闭。</li>
<li>关闭操作只能在发送方 goroutine 上关闭，只能接受的 goroutine 不可被关闭。</li>
<li>在参数中， chan&lt;- int 代表只能发送，&lt;-chan int 代表只能接受。在赋值操作后者难过将双向通道转换为单向通道都是允许的，但是反过来是不行的。</li>
<li>缓冲通道满时，发送会阻塞，为 0 时，接收会阻塞。</li>
<li>无缓冲通道提供强同步保证，因为每一次发送都和一次对景的接收同步，而对于缓冲通道，这些操作是解耦的。<h2 id="select-进行多路复用"><a href="#select-进行多路复用" class="headerlink" title="select 进行多路复用"></a>select 进行多路复用</h2></li>
<li>select 一致等待，直到一次通信操作（通道上的发送或接收）</li>
<li>如果多个情况同时满足， select 随机选择一个，这样保证每一个通道都有相同的机会被选中。</li>
<li>如果不希望被 select 阻塞，则可以使用 default。</li>
<li>可以通过关闭通道的方式来进行取消（关闭后读取值会立即返回）</li>
</ul>
<h1 id="使用共享变量实现并发"><a href="#使用共享变量实现并发" class="headerlink" title="使用共享变量实现并发"></a>使用共享变量实现并发</h1><ul>
<li>如果无法确切的保证一个事件必然优先于另一个事件，那么这两个事件是并发的。如果这个函数在并发调用的情况下依旧能正确工作，那么这个函数是并发安全的。在没有额外同步机制的情况下，从两个或多个 goroutine 同时调用这个函数。</li>
<li>数据竞态发生于两个 goroutine 并发读写同一个变量且至少一个是写入的时候。有三种方法可以避免数据竞态：<ul>
<li>方法不修改变量。那些从不修改的数据结构以及不可变数据结构本质上就是并发安全的，不需要任何同步</li>
<li>避免通过多个 goroutine 访问同一个变量——通过通道来共享内存</li>
<li>允许多个 goroutine 访问统一变量，但在同一时间只有一个 goroutine 可以访问。该机制被成为互斥机制<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2></li>
</ul>
</li>
<li>按照惯例，被互斥量保护的变量声明应该紧跟在互斥量之后，如果实际情况不是如此，就要添加注释来说明此事</li>
<li>lock 和 unlock 之间的代码，可以自由地读取和修改共享变量，这一部分称为临界区域，goroutine 使用完之后应当解锁。</li>
<li>当处理并发程序时，应当永远优先考虑清晰度，拒绝过早的优化。在可以使用的地方，就尽量使用 defer 来让临界区域扩展到函数结尾处。</li>
<li>当使用一个互斥量的时候，要确保互斥量本身和保护的变量都没有被导出</li>
<li>读写互斥锁仅用于在临界区域对共享变量无写操作的情形，一般来讲，我们不应当嘉定那些逻辑上为只读函数或方法不会更新一些变量。<h2 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h2></li>
<li>现代计算机一般有多个处理器，每个处理器都有内存的本地缓存。通道通信或互斥锁操作这样的同步原语都会导致处理器把累计的写操作刷回内存并提交。</li>
<li>在可能的情况下，把变量局限在单个 goroutine 内部，其他的变量都使用互斥锁保护</li>
<li>sync.Once 是专门用于解决延迟初始化的特定方案<h2 id="goroutine-与线程"><a href="#goroutine-与线程" class="headerlink" title="goroutine 与线程"></a>goroutine 与线程</h2></li>
<li>OS 线程的栈大小通常为 2 MB，而 goroutine 的栈不是固定大小的，可以按需增大和缩小</li>
<li>因为 OS 线程是由内核来调度，所以控制全县从一个进程到另一个进程需要一个完整的上下文切换：即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。</li>
<li>与操作系统的线程调度器不同的是，Go 调度器不是由硬件时钟来定期出发的，而是由特定的 Go 语言结构来触发的。</li>
</ul>
<h1 id="包和管理工具"><a href="#包和管理工具" class="headerlink" title="包和管理工具"></a>包和管理工具</h1><ul>
<li>当一个变量并非局部变量时，则对包内的全部文件都可见，如同写在同一个文件里一样。如果名称以大写字母开头，则是导出的，意味着对包外是可见和可访问的。</li>
<li>像 ASCII 或 HTML 这样的首字母缩写词会使用相同的大小写</li>
<li>main 包是很特殊的，该包用于定义一个独立的可运行程序，而不是某个库。在 main 包里，函数 main 也是特殊的。不管在任何函数中， main 做什么事情，总是程序开始执行的地方。当然，main 通常调用其他包中的函数来做更多的事情。</li>
<li>go 程序编译要快过其他语言，原因如下：<ul>
<li>所有导入都在源文件的开头进行显式的列出，这样编译器在确定依赖性时无需处理整个文件</li>
<li>包的依赖性形成有向无环图，因此可以独立甚至并行编译</li>
<li>go 包编译输出的目标文件不仅记录自己的导出信息，还会记录锁依赖包的信息。</li>
</ul>
</li>
<li>包名通常是导入路径的最后一段，有三个例外：<ul>
<li>如果该包定义了一条命令（可执行 Go 程序），那么总使用名称 main。必然会由 go build 生成可执行文件</li>
<li>以 _test.go 结尾文件或者包名中出现_test,该部分用于测试</li>
<li>包名存在版本后缀，则不包括后缀</li>
</ul>
</li>
<li>可以在导入路径前改写包名，不过仅替代当前文件</li>
<li>按照约定，包名是路径的最后一段。包初始化从声明变量开始，会先解析其依赖的顺序</li>
<li>有时需要导入一个包，仅仅为了其副作用：对包级别的变量执行初始化表达式求职，并执行它的 init 函数。例如 import _ “image/png” ，多数情况下，它用来实现一个编译时机制，使用空白引入导入额外的包，从而开启主程序中可选的特性</li>
<li>包的命名通常要求简短而无歧义，如果是处理某一个类的包，那么其中的函数就不必要加上这个类名</li>
<li>pkg 子目录是构建工具存储编译后的包的位置，bin 子目录放置可执行程序。</li>
<li>go get 创建的目录是远程仓库的真实客户端，而不是仅仅是文件的副本，可以使用版本控制命令来查看本地编辑的差异或更新到不同的版本。</li>
<li>go get 指定 -u 开关，go get 将确保所有包都更新到到最新版本。如果没有该标记，则本地的包不会更新。</li>
<li>通过给目录加一层 vendor 目录，可以保证依赖不更新。</li>
<li>go build 命令编译每一个命令行参数中的包。如果包是一个库，结果会被舍弃，对于没有编译错误的包几乎不做检查，go build 会在调用命令的当前目录生成可执行程序，可执行程序名取自包的导入路径的最后一段</li>
<li>默认情况下，go build 命令构建所有需要的包和它们的依赖性，然后丢弃除了最终可执行程序之外的所有编译后的代码</li>
<li>go install 和 go build 非常像,区别在于会保存每一个包的编译代码和命令，而不是丢弃。</li>
<li>go install 和 go build 对于没有改变的包和命令不需要重新编译，从而使后续的构建更加迅速。go build -i 可以将包安装在独立于构建目标的地方。</li>
<li>当路径片段中含有 internal 的情况时，即为内部包，内部包只能被 internal 目录的父目录为跟的目录树中的包锁引用</li>
</ul>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ul>
<li>在 _test.go 文件中，有三种函数需要特殊对待，即功能测试函数、基准测试函数和示例函数。功能测试函数以 Test 开头，用于检测函数的正确性。基准测试函数以 Benchmark 开头，用来测试某些操作的性能， go tests回报操作的平均执行时间。示例函数以 Example 开头，用于提供机器检查过的文档。</li>
<li>测试用例是彼此独立的，如果测试表中一个条目造成测试失败，那么其它的条目依旧会测试，这样可以在一次测试用发现多个失败的情况。若需要终止，则使用 t.Fatal 或者 t.Fatalf 函数来终止测试。这些函数的调用必须和 Test 函数在同一个 goroutine 中，而不是在测试创建的其他的 goroutine 中。</li>
<li>测试代码和产品代码在一个包李敏。尽管包的名称叫做 main，并且李敏定义了一个 main 函数，但是在测试过程中，该包当作库来测试。</li>
<li>白盒测试和黑盒测试的区别即为对包内情况的了解程度。黑盒测试假设测试者对包的了解仅通过公开的 API 和文档美不逻辑是不透明的。而白盒测试可以访问包内部函数和数据结构，并可以做一些改动。</li>
<li>外部测试包用于解决循环引用的问题，当包声明为 url_test,它应该单独地编译一个包，这个包仅包含这些文件，然后通过测试。（可以立即为独立的包）</li>
<li>应该在测试中只处理你关心的属性，选择性的设置断言，并在错误中输出足够的信息。</li>
<li>默认情况下不会运行任何基准测试，当标记 -bench 的参数指定来要运行的基准测试。</li>
<li>Example 函数的后缀可以将实力函数与他所演示的包或函数项关联。如果只叫 Example 关联，那么就和包 word 相关联。</li>
</ul>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li>反射的处理和类型断言有些类似，当我们无法透视一个未知类型的布局时，这段代码就无法继续，这时就需要反射了。</li>
<li>反射类型由 reflect 包提供，其中最重要的两个类型是 Type 和 Value。</li>
<li>reflect.Type 接口只有一个实现，即类型描述符，接口里的动态值也是类型描述符</li>
<li>reflect.TypeOf 返回一个接口值对应的动态类型，所以它总是返回具体类型（而不是接口类型）</li>
<li>reflect.ValueOf 函数接受任意的 interface{} 并将接口的动态值以 reflect.Value 的形式返回。</li>
<li>reflect.Value 和 interface 都可以包含任意的值。二者的区别在于空接口会隐藏值的布局信息、内置操作和相关方法，所以除非我们知道它的动态类型，并用一个断言渗透进去，否则能做的事情就很少了。而 Value 则有很多方法可以用来分析所包含的值。</li>
<li>relfect 和 Kind 方法可以很好的区分不同的类型<h2 id="坏处"><a href="#坏处" class="headerlink" title="坏处"></a>坏处</h2></li>
<li>反射应当谨慎使用，因为基于反射的代码是很脆弱的。正常情况下编译器可以在编译时报告错误，而反射错误则要等到执行时才以崩溃的方式来报告。</li>
<li>反射降低了自动重构和分析工具的安全性和准确度，因为它们无法检测到类型信息。</li>
<li>类型本身就是一种文档，大量的使用反射就如同动态语言一样让人难以理解。</li>
<li>基于反射的函数会比为特定类型优化的函数要慢一到两个数量级，在关键路径上会大幅降低速度，不过用在测试里是无所谓的事情。 </li>
</ul>
<h1 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h1><ul>
<li>i++ 是语句而不是表达式，另外，只支持后置而不支持前置</li>
<li>Go 不允许无意义的临时变量，不然会出现编译错误。</li>
<li>Go 没有构造或析构函数，没有形参默认值，没有范型</li>
<li>一个 ServerMux 可以把多个 http.handler 合成为一个 http.handler</li>
<li>在创建预分配空间 map、channel、预分配空间 slice。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/09/编码-url-和-base64/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/09/编码-url-和-base64/" itemprop="url">编码: url 和 base64</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-09T20:04:53+08:00">
                2019-06-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>今天突然想到一个问题，为什么需要 url 编码 和 base64 编码呢？如果不做处理会有什么问题呢？</p>
</blockquote>
<h1 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h1><p>在日常生活中文本通常是用 ASCII 表示，而 ASCII 编码的是使用 7 bit 来表示的，大多数些操作系统上则会使用字节 8bit 来存储二进制数据，这样直接使用 ASCII 就可能会出问题。</p>
<p>而标准 base64 共 6 位，即共有 64 个字符（英文大小写、数字和+、/），通过将 3 个 ASCII 字符转化为 4 个 base64 字符，就可以保证规避那些可能出错的 ASCII。转化后的 base64 长度必然能被 4 整除（不算等号）</p>
<p>显然，不是所有文本长度都是 3 的整数倍，因此，当不能被 3 整除时，就用 \0 补齐, 有几个 \0 就有几个 =。</p>
<h1 id="URL-编码"><a href="#URL-编码" class="headerlink" title="URL 编码"></a>URL 编码</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>URL 中通过 &amp; 分隔参数，通过 = 来分隔 key 和 value，但是存在一个问题，如果 key 或者 value 中存在 &amp; 和 = 应当如何处理呢？<br>答案就是通过编码保证这些值避免这些问题，这些需要编码的字符即为不安全字符。</p>
<ul>
<li>空格：Url在传输的过程，或者用户在排版的过程，或者文本处理程序在处理Url的过程，都有可能引入无关紧要的空格，或者将那些有意义的空格给去掉。</li>
<li>引号以及&lt;&gt;：引号和尖括号通常用于在普通文本中起到分隔Url的作用</li>
<li>#：通常用于表示书签或者锚点</li>
<li>%：百分号本身用作对不安全字符进行编码时使用的特殊字符，因此本身需要编码</li>
<li>{}|\^[]`~：某一些网关或者传输代理会篡改这些字符</li>
</ul>
<p>Url编码默认使用的字符集是US-ASCII。例如a在US-ASCII码中对应的字节是0x61，那么Url编码之后得到的就是%61，对于非 ASCII 编码，通常使用 Unicode 的 utf-8 来进行编码。</p>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>在 JS 中， encodeURI 和 encodeURIComponent 的安全字符是不同的，分别如下：</p>
<ul>
<li>encodeURI（82个）：!#$&amp;’()*+,/:;=?@-._~0-9a-zA-Z</li>
<li>encodeURIComponent（71个）：!’()*-._~0-9a-zA-Z</li>
</ul>
<p>encodeURI 需要处理整个 URL，因此很多字符不应当处理，而 encodeURIComponent 则是指 key 或者 value。</p>
<p>表单提交的时候每个值都会经过 URL 编码，但是并不是最新标准。</p>
<p>另外，很多HTTP监视工具或者浏览器地址栏等在显示Url的时候会自动将Url进行一次解码（使用UTF-8字符集），这就是为什么当你在Firefox中访问Google搜索中文的时候，地址栏显示的Url包含中文的缘故。但实际上发送给服务端的原始Url还是经过编码的。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/58479085" target="_blank" rel="noopener">为什么要进行URL编码</a></li>
<li><a href="https://www.zhihu.com/question/36306744/answer/71626823" target="_blank" rel="noopener">为什么要使用base64编码</a></li>
<li><a href="https://stackoverflow.com/questions/3538021/why-do-we-use-base64" target="_blank" rel="noopener">Why do we use Base64?</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/09/server-端认证-cookie-session-and-token/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/09/server-端认证-cookie-session-and-token/" itemprop="url">server 端认证:cookie,session and token</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-09T18:33:01+08:00">
                2019-06-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最初的 Web 时代基本只需要阅读信息，所以无所谓身份认证。但是后续很多应用的出现，让身份认证变成了必须要存在的东西。本文简要介绍三个常见的手段:cookie, session 还有 token</p>
<h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p>cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。由于 cookie 在客户端是完全可见且可修改的，因此不适合放一些机密的东西，也不适合把权限认证完全放在这一层来做。<br>此外，cookie 存在着 CORS 问题，即当需要进行跨域时，在前端应当设置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials= true;</span><br></pre></td></tr></table></figure></p>
<p>而在服务器端应当设置以下内容，借此表示后端愿意获得跨域 cookie 内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: a.com //这里需要换成相应的发起请求的域名</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure></p>
<h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p>session 是将必要信息在服务器端存储，以此来辨认客户端身份的做法。<br>session 可能在服务器的内存来存放，也可能在 NOSQL 里集中存放，当存在负载均衡的时候，如何保证每一次访问都可以到指定 session 是一个很严重的问题。</p>
<h1 id="token"><a href="#token" class="headerlink" title="token"></a>token</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>token 是一种无状态的身份认证手段，拥有可扩展、跨设备（更适合移动端）、跨应用、安全的特点。基于 token 的认证流程如下:</p>
<ol>
<li>用户通过用户名和密码发送请求。</li>
<li>程序验证。</li>
<li>程序返回一个签名的token 给客户端。</li>
<li>客户端储存token,并且每次发送请求都携带token。</li>
<li>服务端验证token并返回数据。<br><img src="https://pic1.zhimg.com/80/v2-26d5210a9c95c3a112372a12555118d4_hd.jpg" alt="token 流程图"></li>
</ol>
<p>token 本质上是用时间换空间，通过每次请求都进行校验，来避免使用空间来存储 session。</p>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT(JSON Web Token) 是应用度很广的一种 token 标准，该标准的 token 中会存在三个部分——Header,Payload 和 $Signature，三者之间由 . 分隔。</p>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 是一个 JSON 对象，对象里有一个值为 “JWT” 的 typ 属性，以及 alg 属性，值为 HS256，表明最终使用的加密算法是 HS256。该对象被 Base64 编码。</p>
<h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>Payload 被定义为实体的状态，就像 token 自身附加元数据一样，claim 包含我们想要传输的信息，以及用于服务器验证的信息，一般有 reserved/public/private 三类。<br>其中 Registered claims 指的是官方推荐但是不强制的一些属性，Public claims 属于公共约定的部分，有特定的地方进行注册，Private claims 就是开发者自行约定的，不需要遵循什么。</p>
<h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>$Signature 则是算法计算后的结果，该算法使用两个参数，第一个是 Base64 编码之后的 Header 和 Payload，第二个是服务器的密钥。<br>通过计算 token 里的前两段和 $Signature 是否一致，就可以判断 token 是否被修改，若无修改，则证明着确实是我们下发的 token，应予以通过。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>JWT 只能保证信息不被修改，无法保证不被看到，因此，不应该放一些关键信息在 token 中</li>
<li>token 被窃取的情况是无法避免的，服务器无法判断这一点。</li>
</ul>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>体积小（一串字符串）。因而传输速度快</li>
<li>传输方式多样。可以通过 HTTP 头部（推荐）/URL/POST 参数等方式传输</li>
<li>严谨的结构化。它自身（在 payload 中）就包含了所有与用户相关的验证消息，如用户可访问路由、访问有效期等信息，服务器无需再去连接数据库验证信息的有效性，并且 payload 支持应用定制</li>
<li>支持跨域验证，多应用于单点登录</li>
</ul>
<p><strong>单点登录（Single Sign On）：在多个应用系统中，用户只需登陆一次，就可以访问所有相互信任的应用。</strong></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/27370773" target="_blank" rel="noopener">Server端的认证神器——JWT(一)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/63061864" target="_blank" rel="noopener">彻底理解cookie，session，token</a></li>
<li><a href="https://medium.com/dev-bits/a-guide-for-adding-jwt-token-based-authentication-to-your-single-page-nodejs-applications-c403f7cf04f4" target="_blank" rel="noopener">A guide for adding JWT token-based authentication to your single page Node.js applications</a></li>
<li><a href="https://jwt.io/introduction/" target="_blank" rel="noopener">Introduction to JSON Web Tokens</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/03/linux-常见命令汇总/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/linux-常见命令汇总/" itemprop="url">linux 常见命令汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-03T13:21:59+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="记录日期"><a href="#记录日期" class="headerlink" title="记录日期"></a>记录日期</h1><ul>
<li>date: 获取当前日期</li>
<li>cal: 获取日历</li>
</ul>
<h1 id="记录文件跳转"><a href="#记录文件跳转" class="headerlink" title="记录文件跳转"></a>记录文件跳转</h1><ul>
<li>pwd: 列出当前所在的路径</li>
<li>cd: 更改当前所在目录</li>
<li>ls: 列出系统文件内容</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><ul>
<li>以 .开头的文件名是隐藏文件。这表示 ls 命令不能列出它们。而 ls -a 就可以，而很多配置文件就是以这个形式隐藏在 home 目录下的</li>
<li>文件名和目录名是大小写敏感的</li>
<li>linux 文件名支持空格和标点符号，但标点符号仅允许 ‘.’, ‘-‘ 和下划线，此外，不要在文件名中使用 空格，而是用下划线来替代它。</li>
<li>常见命令选项:<br>  -a    –all    列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。<br>  -d    –directory    通常，如果指定了目录名，ls 命令会列出这个目录中的内容，而不是目录本身。 把这个选项与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。<br>  -F    –classify    这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是 目录名，则会加上一个’/‘字符。<br>  -h    –human-readable    当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。<br>  -l        以长格式显示结果。<br>  -r    –reverse    以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。<br>  -S        命令输出结果按照文件大小来排序。<br>  -t        按照修改时间来x排序。<br>  -i  展示文本节点号</li>
</ul>
<h1 id="linux-系统中的目录"><a href="#linux-系统中的目录" class="headerlink" title="linux 系统中的目录"></a>linux 系统中的目录</h1><ul>
<li>/: 根目录</li>
<li>/bin: 包含系统启动和运行所必须的二进制程序</li>
<li>/etc: 所有系统层面的配置文件。也包含一些脚本，这些脚本应在系统启动时运行，其中你每个文件都应该是可读的文件</li>
<li>/home: 系统给每个用户分配一个目录。普通用户只能在自己的目录下写文件</li>
<li>/lib: 包含核心系统程序所使用的共享库文件</li>
<li>/opt: 这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能安装在系统中的商业软件产品</li>
<li>/tmp: 这个/tmp 目录，是用来存储由各种程序创建的临时文件的地方。一些配置导致系统每次 重新启动时，都会清空这个目录</li>
<li>/usr: 在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件</li>
<li>/usr/local: 这个/usr/local 目录，是非系统发行版自带程序的安装目录。 通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中会存在这个目录， 并且在管理员安装程序之前，这个目录是空的。</li>
<li>/var: 除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录存放的是动态文件。各种数据库，假脱机文件， 用户邮件等等，都位于在这里。</li>
</ul>
<h1 id="文件链接"><a href="#文件链接" class="headerlink" title="文件链接"></a>文件链接</h1><ul>
<li>ln file link(ln -s file link)<h2 id="硬连接"><a href="#硬连接" class="headerlink" title="硬连接"></a>硬连接</h2>最初的链接方式，直接连接一个文件，会导致 ls -l 时的连接数增加，不能跨文件系统、不能关联目录<h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2>多个文件名指向的实际是同一个文件，该方法可以很好的管理一些文件的版本问题。<br>很好的解决了硬连接的问题，但是如果目标文件被删除，那么会产生坏连接。</li>
</ul>
<h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><ul>
<li><ul>
<li>匹配任意多个字符（包括零个或一个）</li>
</ul>
</li>
<li>?    匹配任意一个字符（不包括零个）</li>
<li>[characters]    匹配任意一个属于字符集中的字符</li>
<li>[!characters]    匹配任意一个不是字符集中的字符</li>
<li>[[:class:]]    匹配任意一个属于指定字符类中的字符</li>
</ul>
<h2 id="字符类含义"><a href="#字符类含义" class="headerlink" title="字符类含义"></a>字符类含义</h2><ul>
<li>[:alnum:]    匹配任意一个字母或数字</li>
<li>[:alpha:]    匹配任意一个字母</li>
<li>[:digit:]    匹配任意一个数字</li>
<li>[:lower:]    匹配任意一个小写字母</li>
<li>[:upper:]    匹配任意一个大写字母</li>
</ul>
<h1 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h1><ul>
<li>cp — 复制文件和目录</li>
<li>mv — 移动/重命名文件和目录</li>
<li>mkdir — 创建目录</li>
<li>rm — 删除文件和目录</li>
</ul>
<h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><ul>
<li>cp item1 item2   把 item1 复制到 item2</li>
<li>cp item… directionary   复制多个文件到目录下</li>
<li>当出现 cp -r dir1 dir2 时，若存在 dir2，则 dir1 及其内容会出现在 dir2 内，否则会创建一个 dir2，其内容与 dir1 相同</li>
</ul>
<h3 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h3><ul>
<li>-a, –archive    复制文件和目录，以及它们的属性，包括所有权和权限。 通常，副本具有用户所操作文件的默认属性。</li>
<li>-i, –interactive    在重写已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认重写文件。</li>
<li>-r, –recursive    递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者-a 选项）</li>
<li>-u, –update    当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。</li>
<li>-v, –verbose    显示翔实的命令操作信息</li>
</ul>
<h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><ul>
<li>mv item1 item2</li>
<li>mv item… directory</li>
<li>mv dir1 dir2（同样存在 dir2 是否存在的问题）</li>
</ul>
<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><ul>
<li>-i, –interactive    在删除已存在的文件前，提示用户确认信息。 如果不指定这个选项，rm 会默默地删除文件</li>
<li>-r, –recursive    递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。</li>
<li>-f, –force    忽视不存在的文件，不显示提示信息。这选项覆盖了“–interactive”选项。</li>
<li>-v, –verbose    在执行 rm 命令时，显示翔实的操作信息。</li>
</ul>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>命令分为以下四种：</p>
<ol>
<li>是一个可执行程序，就像我们所看到的位于目录/usr/bin 中的文件一样。 这一类程序可以是用诸如 C 和 C++语言写成的程序编译的二进制文件, 也可以是由诸如shell，perl，python，ruby等等脚本语言写成的程序 </li>
<li>是一个内建于 shell 自身的命令。bash 支持若干命令，内部叫做 shell 内部命令 (builtins)。例如，cd 命令，就是一个 shell 内部命令</li>
<li>是一个 shell 函数。这些是小规模的 shell 脚本，它们混合到环境变量中。 在后续的章节里，我们将讨论配置环境变量以及书写 shell 函数。但是现在， 仅仅意识到它们的存在就可以了</li>
<li>是一个命令别名。我们可以定义自己的命令，建立在其它命令之上</li>
</ol>
<h2 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h2><ul>
<li>type   type command 用来分辨该命令是哪种类型</li>
<li>which  判断该命令的来源（只对可执行程序有效）</li>
<li>help   获取文档</li>
<li>–help 用来显示用法信息</li>
<li>alias<ul>
<li>alias name=’string’  用于生成命令的别名</li>
<li>alias 显示目前的 alias</li>
<li>unalias foo 解除某个 alias</li>
</ul>
</li>
</ul>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>首先，我们要明白标准输入、标准输出和错误输出的概念，通常而言，标准输入连接在键盘，输出连接显示器，但这是可以改变的。</p>
<p>我们可以通过一些符号来完成重定向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /usr/bin &gt; ls-output.txt</span><br></pre></td></tr></table></figure></p>
<p>要注意的是， &gt; 会覆盖之前的内容，因此，当我们需要清空某个文件的内容时，可以使用 &gt; a.txt 的方式来解决。而如果我们要做的是跟在后面，那么应当使用 &gt;&gt;。</p>
<p>标准错误重定向使用的符号是 2&gt;, 且必须放在 &gt; 的后面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /bin/usr 2&gt; ls-error.txt</span><br></pre></td></tr></table></figure></p>
<p>&lt; 符号可以使后面的文件内容作为前面命令的输入</p>
<h2 id="管道线"><a href="#管道线" class="headerlink" title="管道线"></a>管道线</h2><p>管道线的符号为 |，其作用是使得前一个命令的结果作为下一个命令的输出。<br>在管道线中，有以下命令经常被使用</p>
<ul>
<li>cat  查看文件的内容（也可以将多个文件的内容归一）</li>
<li>sort 排序</li>
<li>uniq 报道或忽略重复航（使用 -d 时可以看到重复行）</li>
<li>wc   统计文件的行数、字数、字节数，使用 -l 可以只统计行数</li>
<li>grep grep pattern [file…] 所谓 pattern 就是正则</li>
<li>head / tail -n  打印开头或结尾前几行</li>
<li>tee  从 Stdin 读取数据，并同时输出到 Stdout 和文件（保证流不中断）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/bin | tee ls.txt | grep zip</span><br></pre></td></tr></table></figure>
<h1 id="展开符"><a href="#展开符" class="headerlink" title="展开符"></a>展开符</h1><h2 id="花括号展开"><a href="#花括号展开" class="headerlink" title="花括号展开"></a>花括号展开</h2><ul>
<li>{A,B,C} : A,B,C</li>
<li>{1..5} : 从 1 - 5</li>
</ul>
<h2 id="或"><a href="#或" class="headerlink" title="$ 或 `"></a>$ 或 `</h2><p>$(x) 可以让我们把 x 当作变量来读取，也可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file $(ls /usr/bin/* | grep zip)</span><br></pre></td></tr></table></figure></p>
<h2 id="“”"><a href="#“”" class="headerlink" title="“”"></a>“”</h2><p>在双引号中，参数展开、算数表达式展开和命令替换仍然有效（但是禁止花括号展开）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo &quot;$USER $((2+2)) $(cal)&quot;</span><br><span class="line">me 4    February 2008</span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br></pre></td></tr></table></figure></p>
<p>此外，空格不会成为分隔符，只有换行符才会进行分割</p>
<h2 id="‘"><a href="#‘" class="headerlink" title="‘"></a>‘</h2><p>单引号中禁止所有的展开,而转义符也会失去它的含义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER</span><br><span class="line">text /home/me/ls-output.txt a b foo 4 me</span><br><span class="line">[me@linuxbox ~]$ echo &quot;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&quot;</span><br><span class="line">text ~/*.txt   &#123;a,b&#125; foo 4 me</span><br><span class="line">[me@linuxbox ~]$ echo &apos;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&apos;</span><br><span class="line">text ~/*.txt  &#123;a,b&#125; $(echo foo) $((2+2)) $USER</span><br></pre></td></tr></table></figure></p>
<h1 id="命令行常见技巧"><a href="#命令行常见技巧" class="headerlink" title="命令行常见技巧"></a>命令行常见技巧</h1><ul>
<li>ctrl-a : 移动光标到行首</li>
<li>ctrl-e:  移动光标到行尾</li>
<li>ctrl-l:  同 clear</li>
<li>ctrl-k:  剪切从光标位置到行尾的文本</li>
<li>ctrl-u:  剪切从光标位置到行首的文本</li>
<li>ctrl-y:  把剪切环中的文本粘贴到光标位置</li>
<li>ctrl-r:  反向搜索包含该字符串的命令</li>
<li>ctrl-o:  执行历史列表中的当前项，并移到下一个。如果你想要执行历史列表中一系列的命令，这很方便</li>
</ul>
<h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><h2 id="第一个字符含义"><a href="#第一个字符含义" class="headerlink" title="第一个字符含义"></a>第一个字符含义</h2><ul>
<li><ul>
<li>: 一个普通的文件</li>
</ul>
</li>
<li>d : 一个目录</li>
<li>l : 一个 symbol link</li>
<li>c : 一个字符设备文件</li>
<li>b : 一个块设备文件</li>
</ul>
<h2 id="不同权限含义"><a href="#不同权限含义" class="headerlink" title="不同权限含义"></a>不同权限含义</h2><ul>
<li>r    允许打开并读取文件内容    允许列出目录中的内容，前提是目录必须设置了可执行属性（x）</li>
<li>w    允许写入文件内容或截断文件。但是不允许对文件进行重命名或删除，重命名或删除是由目录的属性决定的    允许在目录下新建、删除或重命名文件，前提是目录必须设置了可执行属性（x）</li>
<li>x    允许将文件作为程序来执行，使用脚本语言编写的程序必须设置为可读才能被执行    允许进入目录，例如：cd directory </li>
</ul>
<h2 id="改变文件权限-chmod"><a href="#改变文件权限-chmod" class="headerlink" title="改变文件权限(chmod)"></a>改变文件权限(chmod)</h2><ul>
<li>数字表示法: 从 0 开始，八进制的顺序为 rwx</li>
<li>符号表示法: u:user, g: group, o:others, a:all<ul>
<li>u+r user 增加 r 权限</li>
<li>a-x 所有人减少 x 权限</li>
<li>go=rw g 和 o 权限为读写</li>
</ul>
</li>
<li>默认权限设置: unmask, 使用的是八进制掩码(要注意，从 0 开始，一共四位)，且只对当前 shell 有效</li>
</ul>
<h2 id="更改用户身份"><a href="#更改用户身份" class="headerlink" title="更改用户身份"></a>更改用户身份</h2><ul>
<li>su -l 要求以某用户身份开启窗口，用户为空，则是超管，然后要求输入指定用户的密码</li>
<li>sudo 以另一个用户的身份执行命令，输入自己的密码</li>
</ul>
<h2 id="改变文件所有者和用户-chown"><a href="#改变文件所有者和用户-chown" class="headerlink" title="改变文件所有者和用户(chown)"></a>改变文件所有者和用户(chown)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [owner][:[group]] file...</span><br></pre></td></tr></table></figure>
<ul>
<li>bob    把文件所有者从当前属主更改为用户 bob</li>
<li>bob:users    把文件所有者改为用户 bob，文件用户组改为用户组 users</li>
<li>:admins    把文件用户组改为组 admins，文件所有者不变</li>
<li>bob:    文件所有者改为用户 bob，文件用户组改为用户 bob 登录系统时所属的用户组</li>
</ul>
<h2 id="更改用户密码-passwd"><a href="#更改用户密码-passwd" class="headerlink" title="更改用户密码(passwd)"></a>更改用户密码(passwd)</h2><p>只输入 passwd 可以更改自己的密码，如果有管理员权限，则可以改其他人的</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>当系统启动的时候，内核先把一些它自己的活动初始化为进程，然后运行一个叫做 init 的程序。init， 依次地，再运行一系列的称为 init 脚本的 shell 脚本（位于/etc），它们可以启动所有的系统服务。 其中许多系统服务以守护（daemon）程序的形式实现，守护程序仅在后台运行，没有任何用户接口(User Interface)。 这样，即使我们没有登录系统，至少系统也在忙于执行一些例行事务。</p>
<h2 id="ps-报告当前进程快照，使用-x-可以看全部进程"><a href="#ps-报告当前进程快照，使用-x-可以看全部进程" class="headerlink" title="ps(报告当前进程快照，使用 x 可以看全部进程)"></a>ps(报告当前进程快照，使用 x 可以看全部进程)</h2><ul>
<li>TTY: 控制终端</li>
<li>TIME: 消耗 cpu 时间vim</li>
<li>CMD: 启动命令</li>
<li>STAT: R(运行中或准备运行)、S(睡眠，进程没有运行，在等待事件)、D(不可中断睡眠，等待 IO 事件)、T（已停止）、Z（已终止子进程，但是还没有被父进程清空）、&lt; (高优先级进程)、N（低优先级进程）</li>
</ul>
<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>可以动态的观察系统的状态，以下参数:</p>
<ul>
<li>Load Avg: 等待运行的进程并共享CPU的个数，三个值分别是 60s, 5min, 15min 的平均值</li>
<li>CPUS: us(用户)、sy（系统内核）、ni（低优先级）、ideal（空闲）、wa（等待 IO）</li>
</ul>
<h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><p>在命令之后加 &amp; 即为后台运行<br>如果要终止一个进程，应当使用 ctrl-c,如果只是停止，那么应该用 ctrl-z</p>
<h2 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h2><p>查看当前活跃任务<br>参数以 %n 的形式指出</p>
<ul>
<li>bg 将某个任务转为后台</li>
<li>fg 将某个任务转为前台</li>
</ul>
<h2 id="常用信号"><a href="#常用信号" class="headerlink" title="常用信号"></a>常用信号</h2><ul>
<li>1  HUP   挂起，可以重新进行初始化</li>
<li>2  INT   中断，同 ctrl-c</li>
<li>9  KILL  杀死，内核级的处理，不会给程序收尾的机会</li>
<li>15 TEAM  终止，kill 的默认信号</li>
<li>18 CONT  继续，恢复进程运行</li>
<li>19 STOP  停止，停止运行</li>
<li>3  QUIT  退出</li>
<li>20 TSTP  终端终止，同 ctrl-z</li>
</ul>
<h2 id="killall-杀死全部"><a href="#killall-杀死全部" class="headerlink" title="killall(杀死全部)"></a>killall(杀死全部)</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>pstree: 输出一个树型结构的进程列表(processtree)，这个列表展示了进程间父/子关系</li>
<li>vmstart: 输出一个系统资源使用快照，包括内存，交换分区和磁盘 I/O,后面可跟数字表明更新时间</li>
<li>xload: 一个图形化界面程序，画出系统负载随时间变化的图像</li>
<li>tload: 在终端内画出图像</li>
</ul>
<h1 id="shell-环境"><a href="#shell-环境" class="headerlink" title="shell 环境"></a>shell 环境</h1><p>shell 在环境中存储了两种基本类型的数据，虽然 bash 几乎无法分辨这些数据的类型。 它们是环境变量和 shell 变量。Shell 变量是 bash 存放的少量数据。剩下的都是 环境变量。除了变量，shell 也存储了一些可编程的数据，即别名和 shell 函数。</p>
<h2 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h2><ul>
<li>printenv [变量名]</li>
<li>echo $变量名</li>
<li>alias: 查看所有 alias </li>
</ul>
<h2 id="shell-启动文件"><a href="#shell-启动文件" class="headerlink" title="shell 启动文件"></a>shell 启动文件</h2><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><ul>
<li>/etc/profile    应用于所有用户的全局配置脚本</li>
<li>~/.bash_profile    用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置</li>
<li>~/.bash_login    如果文件 ~/.bash_profile 没有找到，bash 会尝试读取这个脚本</li>
<li>~/.profile    如果文件 ~/.bash_profile 或文件 ~/.bash_login 都没有找到，bash 会试图读取这个文件。 这是基于 Debian 发行版的默认设置，比方说 Ubuntu</li>
</ul>
<h3 id="非登陆"><a href="#非登陆" class="headerlink" title="非登陆"></a>非登陆</h3><ul>
<li>/etc/bash.bashrc    应用于所有用户的全局配置文件。</li>
<li>~/.bashrc    用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置</li>
</ul>
<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">^:       行首第一个非空字符</span><br><span class="line">$:       本行行末</span><br><span class="line">ctrl-f:  向下翻一页</span><br><span class="line">ctrl-b:  向上翻一页</span><br><span class="line">gg:      全文第一行</span><br><span class="line">G:       全文最后一行</span><br><span class="line">ngg:     全文第 n 行</span><br><span class="line">nH:      当前页面第几行</span><br><span class="line">M:       跳转当前页面中间</span><br><span class="line">nL:      跳转当前页面倒数第几行</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(n)dd:      删除以下几行</span><br><span class="line">d$^:        删除光标到行首或行尾</span><br><span class="line">dG:     	从当前行到文件的末尾</span><br><span class="line">d20G:   	从当前行到文件的第20行</span><br><span class="line">J:          合并当前行和下一行</span><br></pre></td></tr></table></figure>
<h2 id="复制粘贴撤销重做"><a href="#复制粘贴撤销重做" class="headerlink" title="复制粘贴撤销重做"></a>复制粘贴撤销重做</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p               粘贴至光标之后</span><br><span class="line">P               粘贴至光标之前</span><br><span class="line">(n)yy           复制到内存中</span><br><span class="line">u               撤销</span><br><span class="line">.               重复上一步操作</span><br></pre></td></tr></table></figure>
<h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:w filename     另存为filename</span><br><span class="line">:n              跳转到第n行</span><br><span class="line">:m,nw filename  第m-n行写入文件</span><br><span class="line">:.,$w filename  当前行到最后一行写入文件</span><br><span class="line">:f              显示当前信息，比如文件共几行，光标在第几行</span><br></pre></td></tr></table></figure>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:/str/          正向搜索</span><br><span class="line">:?str?          逆向搜索</span><br><span class="line">:%s/Line/line/g 替换</span><br></pre></td></tr></table></figure>
<h2 id="打开多个文件"><a href="#打开多个文件" class="headerlink" title="打开多个文件"></a>打开多个文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi file1 file2 file3...   同时开多个</span><br><span class="line">:e file2                  追加打开</span><br><span class="line">:buffers                  查看目前已打开的文件</span><br><span class="line">:buffer n                 切到第 n 个</span><br></pre></td></tr></table></figure>
<h1 id="包管理系统"><a href="#包管理系统" class="headerlink" title="包管理系统"></a>包管理系统</h1><h2 id="大致分类"><a href="#大致分类" class="headerlink" title="大致分类"></a>大致分类</h2><ul>
<li>Debian Style (.deb)    Debian, Ubuntu, Xandros, Linspire</li>
<li>Red Hat Style (.rpm)    Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS</li>
</ul>
<h2 id="查找某个包"><a href="#查找某个包" class="headerlink" title="查找某个包"></a>查找某个包</h2><ul>
<li>Debian    apt-get update; apt-cache search search_string</li>
<li>Red Hat    yum search search_string</li>
</ul>
<h2 id="从资源库安装某个包"><a href="#从资源库安装某个包" class="headerlink" title="从资源库安装某个包"></a>从资源库安装某个包</h2><ul>
<li>Debian    apt-get update; apt-get install package_name</li>
<li>Red Hat    yum install package_name</li>
</ul>
<h2 id="通过软件包文件安装文件"><a href="#通过软件包文件安装文件" class="headerlink" title="通过软件包文件安装文件"></a>通过软件包文件安装文件</h2><ul>
<li>Debian    dpkg –install package_file</li>
<li>Red Hat    rpm -i package_file</li>
</ul>
<h2 id="卸载文件包"><a href="#卸载文件包" class="headerlink" title="卸载文件包"></a>卸载文件包</h2><ul>
<li>Debian    apt-get remove package_name</li>
<li>Red Hat    yum erase package_name</li>
</ul>
<h2 id="更新软件包"><a href="#更新软件包" class="headerlink" title="更新软件包"></a>更新软件包</h2><ul>
<li>Debian    apt-get update; apt-get upgrade</li>
<li>Red Hat    yum update</li>
<li>Debian    dpkg –install package_file</li>
<li>Red Hat    rpm -U package_file</li>
</ul>
<h2 id="查询软件包"><a href="#查询软件包" class="headerlink" title="查询软件包"></a>查询软件包</h2><h3 id="查询列表"><a href="#查询列表" class="headerlink" title="查询列表"></a>查询列表</h3><ul>
<li>Debian    dpkg –list</li>
<li>Red Hat    rpm -qa<h3 id="确认是否安装"><a href="#确认是否安装" class="headerlink" title="确认是否安装"></a>确认是否安装</h3></li>
<li>Debian    dpkg –status package_name</li>
<li>Red Hat    rpm -q package_name<h3 id="确认文件对应的软件包"><a href="#确认文件对应的软件包" class="headerlink" title="确认文件对应的软件包"></a>确认文件对应的软件包</h3></li>
<li>Debian    dpkg –search file_name</li>
<li>Red Hat    rpm -qf file_name</li>
</ul>
<h1 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h1><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>ping 用来确认网络通畅，该命令发送一个特殊的网络数据包，为 ICMP ECHO_REQUEST，大多数服务器都会回复它。</p>
<h2 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h2><p>追踪连接到某服务器的网络跳转</p>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>统计各种各样的网络路由，-r检测内核路由</p>
<h2 id="网络中传输文件"><a href="#网络中传输文件" class="headerlink" title="网络中传输文件"></a>网络中传输文件</h2><h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h3><ul>
<li>ftp 通常是是匿名的，用户名为 anonymous，密码随意</li>
<li>lcd 用于切换本地的路径</li>
<li>get … 获取某文件</li>
<li>bye 退出 ftp<h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3></li>
<li>可用于递归下载，可以下载多个文件</li>
</ul>
<h2 id="与远程主机通信"><a href="#与远程主机通信" class="headerlink" title="与远程主机通信"></a>与远程主机通信</h2><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p>用来进行安全连接<br>OpenSSH 软件包也包含两个程序，它们可以利用 SSH 加密通道在网络间复制文件。第一个，scp（安全复制）被用来复制文件，与熟悉的 cp 程序非常相似。第二个 SSH 文件复制程序是 sftp，顾名思义，它是 ftp 程序的安全替代品。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp remote-sys:document.txt .</span><br></pre></td></tr></table></figure>
<h1 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h1><h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><p>用于在文件数据库中查找数据</p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><ul>
<li>-type d、f、l</li>
<li>-size 判断大小</li>
<li>可以使用逻辑操作符 -and,-or,-not,()（注意转义）</li>
</ul>
<h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>这个 xargs 命令会执行一个有趣的函数。它从标准输入接受输入，并把输入转换为一个特定命令的 参数列表。</p>
<h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><ul>
<li>ls 的加强版</li>
</ul>
<h1 id="压缩和归档"><a href="#压缩和归档" class="headerlink" title="压缩和归档"></a>压缩和归档</h1><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>一种 linux 下非常常见的压缩操作，后缀为 .gz</p>
<ul>
<li>-d  解压缩</li>
<li>-r  递归</li>
</ul>
<h2 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h2><p>类似于 gzip，但是压缩算法不同，舍弃了压缩速度实现了更高层级的压缩，扩展名为 .bz2</p>
<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>tar 是一种归档命令，它有非常多的模式</p>
<ul>
<li>c: creative,创建归档文件</li>
<li>v: 显示操作过程</li>
<li>f: 指定归档后的文件名</li>
<li>g: 以 gzip 进行压缩</li>
<li>t: 列出归档内容</li>
<li>x: 提取相关文件</li>
<li>p: 保留原文件权限</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf test.tar.gz  test/*    //压缩</span><br><span class="line">tar -ztvf test.tar.gz      // 查看内容</span><br><span class="line">tar -zxvf test.tar.gz       //解压缩</span><br></pre></td></tr></table></figure>
<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>本身既是归档又是压缩，但是用得很少，主要用于和 Windows 交互<br>zip -r ; unzip</p>
<h2 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h2><p>用于远程同步（也可以本地同步，但是至少要有一个在本地）</p>
<h1 id="linux-里的正则"><a href="#linux-里的正则" class="headerlink" title="linux 里的正则"></a>linux 里的正则</h1><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><ul>
<li>i 忽略大小写</li>
<li>v 不匹配</li>
<li>l 输出匹配的文件名，而不是内容</li>
<li>n 打印出对应文件中的行号</li>
</ul>
<h2 id="POSIX-字符集"><a href="#POSIX-字符集" class="headerlink" title="POSIX 字符集"></a>POSIX 字符集</h2><ul>
<li>[:alnum:]    字母数字字符。在 ASCII 中，等价于：[A-Za-z0-9]</li>
<li>[:word:]    与[:alnum:]相同, 但增加了下划线字符。</li>
<li>[:alpha:]    字母字符。在 ASCII 中，等价于：[A-Za-z]</li>
<li>[:blank:]    包含空格和 tab 字符。</li>
<li>[:digit:]    数字0到9</li>
</ul>
<h2 id="BRE"><a href="#BRE" class="headerlink" title="BRE"></a>BRE</h2><p>在 BRE 中，( ) { } ? + | 不被认为是元字符，需要手动转义（grep 和 vim 中都是BRE）<br>find 命令中不是 BRE，也就是说，不需要转义任何东西</p>
<h1 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h1><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>将多个文件连接，-n 显示行号</p>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>对进行排序（默认是每一行）</p>
<ul>
<li>-f: 不区分大小写</li>
<li>-r: 相反顺序</li>
<li>-n: 按照数值排序，而不是字符串值</li>
</ul>
<h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><ul>
<li>-c: 输出所有重复行，并且显示每行重复的次数</li>
<li>-d: 只输出重复行</li>
<li>-u: 只输出独有行，默认</li>
<li>-f n: 忽略每行开头的 n 个字符</li>
</ul>
<h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><p>从文件中抽取一些内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -d &apos;:&apos; -f 1 /etc/passwd | head</span><br></pre></td></tr></table></figure></p>
<ul>
<li>-d: 代表分隔符是什么，默认是单个 tab</li>
<li>-f: 抽取第几段</li>
<li>-c: 抽取定义的 chat_list 文本</li>
</ul>
<h2 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h2><p>将某一列内容插入进去</p>
<h2 id="comm"><a href="#comm" class="headerlink" title="comm"></a>comm</h2><p>comm 命令产生了三列输出。第一列包含第一个文件独有的文本行；第二列， 文本行是第二列独有的；第三列包含两个文件共有的文本行</p>
<ul>
<li>-n: 显示行数</li>
</ul>
<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>diff -u 显示两个文件</p>
<ul>
<li>-:        删除行。这一行将会出现在第一个文件中，而不是第二个文件内。</li>
<li>+:        添加行。这一行将会出现在第二个文件内，而不是第一个文件中。</li>
<li>!:        更改行。将会显示某个文本行的两个版本，每个版本会出现在更改组的各自部分。</li>
</ul>
<h2 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h2><p>运行时编辑，用于转换<br>-s 则用于挤压内容，消除连续重复的文本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;lowercase letters&quot; | tr a-z A-Z</span><br><span class="line">LOWERCASE LETTERS</span><br><span class="line"></span><br><span class="line">echo &quot;aaabbbccc&quot; | tr -s ab</span><br><span class="line">abccc</span><br></pre></td></tr></table></figure></p>
<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>用于查找替换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;front&quot; | sed &apos;2s/front/back/&apos; //将第二行的front替换为back</span><br><span class="line">sed -n &apos;/SUSE/p&apos; distros.txt   // 正则进行查找</span><br><span class="line">SUSE         10.2     12/07/2006</span><br><span class="line">SUSE         11.0     06/19/2008</span><br><span class="line">SUSE         10.3     10/04/2007</span><br><span class="line">SUSE         10.1     05/11/2006</span><br><span class="line">sed -n &apos;/SUSE/!p&apos; distros.txt   // 进行否定</span><br></pre></td></tr></table></figure></p>
<h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><h2 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h2><p>打印行号</p>
<h2 id="fold"><a href="#fold" class="headerlink" title="fold"></a>fold</h2><p>限制文件列宽 -w 指定参数</p>
<h1 id="编译软件"><a href="#编译软件" class="headerlink" title="编译软件"></a>编译软件</h1><h2 id="configure"><a href="#configure" class="headerlink" title="./configure"></a>./configure</h2><p>这个 configure 程序是一个 shell 脚本，由源码树提供。它的工作是分析程序构建环境。大多数源码会设计为可移植的。 也就是说，它被设计成能够在不止一种类 Unix 系统中进行构建。但是为了做到这一点，在建立程序期间，为了适应系统之间的差异， 源码可能需要经过轻微的调整。configure 也会检查是否安装了必要的外部工具和组件。让我们运行 configure 命令。 因为 configure 命令所在的位置不是位于 shell 通常期望程序所呆的地方，我们必须明确地告诉 shell 它的位置，通过 在命令之前加上 ./ 字符，来表明程序位于当前工作目录.<br>我们看到在我们的源码目录中 configure 命令创建了几个新文件。最重要一个是 Makefile。Makefile 是一个配置文件， 指示 make 程序究竟如何构建程序。没有它，make 程序就不能运行。Makefile 是一个普通文本文件，所以我们能查看它：</p>
<h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>make 命令会执行 Makefile 文件，make 命令会保证目标文件是最新的，目标文件必然会新于依赖文件</p>
<h2 id="make-install"><a href="#make-install" class="headerlink" title="make install"></a>make install</h2><p>打包良好的源码经常包括一个特别的 make 目标文件，叫做 install。这个目标文件将在系统目录中安装最终的产品，以供使用。 通常，这个目录是 /usr/local/bin，为在本地所构建软件的传统安装位置。然而，通常普通用户不能写入该目录，所以我们必须变成超级用户， 来执行安装操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p>
<h1 id="编写-bash-脚本"><a href="#编写-bash-脚本" class="headerlink" title="编写 bash 脚本"></a>编写 bash 脚本</h1><h2 id="变量和常量声明"><a href="#变量和常量声明" class="headerlink" title="变量和常量声明"></a>变量和常量声明</h2><ul>
<li>变量: title=”bac”  // 要注意中间不能有空格</li>
<li>title1 = ${title}1 //这样可以局部使用变量</li>
<li>常量: declare -r TITLE=”Page Title” // 习惯上将常量名大写<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function name &#123;</span><br><span class="line">    commands</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name () &#123;</span><br><span class="line">    commands</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>local foo</p>
<h2 id="流程控制之条件"><a href="#流程控制之条件" class="headerlink" title="流程控制之条件"></a>流程控制之条件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if commands; then</span><br><span class="line">     commands</span><br><span class="line">[elif commands; then</span><br><span class="line">     commands...]</span><br><span class="line">[else</span><br><span class="line">     commands]</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>一个简单的 bash 脚本如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># test-string: evaluate the value of a string</span><br><span class="line">ANSWER=maybe</span><br><span class="line">if [ -z &quot;$ANSWER&quot; ]; then</span><br><span class="line">    echo &quot;There is no answer.&quot; &gt;&amp;2</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$ANSWER&quot; = &quot;yes&quot; ]; then</span><br><span class="line">    echo &quot;The answer is YES.&quot;</span><br><span class="line">elif [ &quot;$ANSWER&quot; = &quot;no&quot; ]; then</span><br><span class="line">    echo &quot;The answer is NO.&quot;</span><br><span class="line">elif [ &quot;$ANSWER&quot; = &quot;maybe&quot; ]; then</span><br><span class="line">    echo &quot;The answer is MAYBE.&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;The answer is UNKNOWN.&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>更现代的条件版本是 [[]] 和 (())</p>
<h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><ul>
<li>read variable : 读取某变量</li>
<li>若变量个数少于输入，则多出的都会在最后一个变量上</li>
<li>若只有 read，则全部输入在 REPLY 变量上</li>
<li>变量 IFS 用来说明用什么分隔参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># read-ifs: read fields from a file</span><br><span class="line">FILE=/etc/passwd</span><br><span class="line">read -p &quot;Enter a user name &gt; &quot; user_name</span><br><span class="line">file_info=$(grep &quot;^$user_name:&quot; $FILE)</span><br><span class="line">if [ -n &quot;$file_info&quot; ]; then</span><br><span class="line">    IFS=&quot;:&quot; read user pw uid gid name home shell &lt;&lt;&lt; &quot;$file_info&quot;</span><br><span class="line">    echo &quot;User = &apos;$user&apos;&quot;</span><br><span class="line">    echo &quot;UID = &apos;$uid&apos;&quot;</span><br><span class="line">    echo &quot;GID = &apos;$gid&apos;&quot;</span><br><span class="line">    echo &quot;Full Name = &apos;$name&apos;&quot;</span><br><span class="line">    echo &quot;Home Dir. = &apos;$home&apos;&quot;</span><br><span class="line">    echo &quot;Shell = &apos;$shell&apos;&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;No such user &apos;$user_name&apos;&quot; &gt;&amp;2</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>while commands; do commands; done<br>break 和 continue 一样可用<br>until 和 while 类似，除了条件相反</p>
<h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><p>就是 switch 匹配, ;;&amp; 类似于 switch 的 break<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case word in</span><br><span class="line">    [pattern [| pattern]...) commands ;;]...</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;enter word &gt; &quot;</span><br><span class="line">case $REPLY in</span><br><span class="line">    [[:alpha:]])        echo &quot;is a single alphabetic character.&quot; ;;</span><br><span class="line">    [ABC][0-9])         echo &quot;is A, B, or C followed by a digit.&quot; ;;</span><br><span class="line">    ???)                echo &quot;is three characters long.&quot; ;;</span><br><span class="line">    *.txt)              echo &quot;is a word ending in &apos;.txt&apos;&quot; ;;</span><br><span class="line">    *)                  echo &quot;is something else.&quot; ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<h2 id="访问-bash-脚本参数"><a href="#访问-bash-脚本参数" class="headerlink" title="访问 bash 脚本参数"></a>访问 bash 脚本参数</h2><ul>
<li>$n: 获取第 n 个参数</li>
<li>shift: 所有参数向前移动一位</li>
<li>$0,$*: 拿到所有参数</li>
</ul>
<h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>传统 for 循环是以下的样子,可用使用路径名展开，命令替换或者花括号占考<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for variable [in words]; do</span><br><span class="line">    commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in distros*.txt; do echo $i; done</span><br></pre></td></tr></table></figure>
<p>新 for 循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (( expression1; expression2; expression3 )); do</span><br><span class="line">    commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<h2 id="管理空变量展开"><a href="#管理空变量展开" class="headerlink" title="管理空变量展开"></a>管理空变量展开</h2><h3 id="parameter-word"><a href="#parameter-word" class="headerlink" title="${parameter:-word}"></a>${parameter:-word}</h3><p>本方法为一次性，若 parameter 没有设置（例如，不存在）或者为空，展开结果是 word 的值。若 parameter 不为空，则展开结果是 parameter 的值。</p>
<h3 id="parameter-word-1"><a href="#parameter-word-1" class="headerlink" title="${parameter:=word}"></a>${parameter:=word}</h3><p>可以理解为赋默认值</p>
<h3 id="parameter-word-2"><a href="#parameter-word-2" class="headerlink" title="${parameter:?word}"></a>${parameter:?word}</h3><p>若 parameter 没有设置或为空，这种展开导致脚本带有错误退出，并且 word 的内容会发送到标准错误。若 parameter 不为空， 展开结果是 parameter 的值。</p>
<h3 id="parameter-word-3"><a href="#parameter-word-3" class="headerlink" title="${parameter:+word}"></a>${parameter:+word}</h3><p>若 parameter 没有设置或为空，展开结果为空。若 parameter 不为空， 展开结果是 word 的值会替换掉 parameter 的值；然而，parameter 的值不会改变。</p>
<h2 id="变量名展开"><a href="#变量名展开" class="headerlink" title="变量名展开"></a>变量名展开</h2><p>${!prefix*}、${!prefix@}：列出以 prefix 开头的变量名</p>
<h3 id="查看长度"><a href="#查看长度" class="headerlink" title="查看长度"></a>查看长度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#parameter&#125;</span><br></pre></td></tr></table></figure>
<p>展开成由 parameter 所包含的字符串的长度。通常，parameter 是一个字符串；然而，如果 parameter 是 @ 或者是 * 的话， 则展开结果是位置参数的个数。</p>
<h3 id="parameter-offset-length"><a href="#parameter-offset-length" class="headerlink" title="${parameter:offset:length}"></a>${parameter:offset:length}</h3><p>进行一个截断，length默认是全部，offset若是负值就倒着算</p>
<h3 id="定点清楚"><a href="#定点清楚" class="headerlink" title="定点清楚"></a>定点清楚</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;parameter#pattern&#125;、$&#123;parameter##pattern&#125;、$&#123;parameter%pattern&#125;、$&#123;parameter%%pattern&#125;</span><br></pre></td></tr></table></figure>
<p>进行清除，分别是前面最短、最长，后面</p>
<h2 id="大小写处理"><a href="#大小写处理" class="headerlink" title="大小写处理"></a>大小写处理</h2><h3 id="declare"><a href="#declare" class="headerlink" title="declare"></a>declare</h3><ul>
<li>declare -u upper</li>
<li>declare -l lower<h3 id="大小写展开"><a href="#大小写展开" class="headerlink" title="大小写展开"></a>大小写展开</h3></li>
<li>${parameter,,}    把 parameter 的值全部展开成小写字母。</li>
<li>${parameter,}    仅仅把 parameter 的第一个字符展开成小写字母。</li>
<li>${parameter^^}    把 parameter 的值全部转换成大写字母。</li>
<li>${parameter^}    仅仅把 parameter 的第一个字符转换成大写字母（首字母大写）。</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>创建一个数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[1] = &apos;333&apos;</span><br><span class="line">declare -a a</span><br><span class="line">name=(value1 value2 ...)    // 多赋值</span><br></pre></td></tr></table></figure></p>
<p>${!array[@]}用引号引起来的 @ 格式是最有用的， 因为它能展开成分离的词。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=([2]=a [4]=b [6]=c)</span><br><span class="line">[me@linuxbox ~]$ for i in &quot;$&#123;foo[@]&#125;&quot;; do echo $i; done</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">[me@linuxbox ~]$ for i in &quot;$&#123;!foo[@]&#125;&quot;; do echo $i; done</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p>
<p>在数组末尾追加元素: foo+=(d e f)<br>删除数组使用 unset 命令<br>关联数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare -A colors</span><br><span class="line">colors[&quot;red&quot;]=&quot;#ff0000&quot;</span><br><span class="line">colors[&quot;green&quot;]=&quot;#00ff00&quot;</span><br><span class="line">colors[&quot;blue&quot;]=&quot;#0000ff&quot;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/30/react-总结汇总/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/30/react-总结汇总/" itemprop="url">react 总结汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-30T15:11:41+08:00">
                2019-04-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="react-生命周期"><a href="#react-生命周期" class="headerlink" title="react 生命周期"></a>react 生命周期</h1><p><img src="https://upload-images.jianshu.io/upload_images/4345168-fd3988bc7dcfee69.png" alt="react 生命周期图"></p>
<p>我们可以将 react 生命周期分为两种：当组件在挂载或卸载时和当组件产生实质性更新时。</p>
<p>DOM 真正被添加到 HTML 中的生命周期方法时 componentDidMount 和 componentDidUpdate 中，因此，在这两个方法中去取得 DOM 元素才是有意义的。而取得 DOM 元素的方法有两种，其一是 findDOMNode（只对已挂载组件有作用），其二则是 render 方法中的回调。</p>
<p>在 componentWillReceiveProps 中调用 setState 是很正常的操作，但是经测试，就算不调用，props 的改变也会导致整个子组件的更新。</p>
<h1 id="react-事件机制"><a href="#react-事件机制" class="headerlink" title="react 事件机制"></a>react 事件机制</h1><ul>
<li>react 并不会把时间处理函数直接绑定到真实的节点上，而是把所有时间绑定到结构的最外层，使用一个统一的事件监听器。</li>
<li>在某些情况下我们可能需要使用原生的事件，通常是在 componentDidMount 中挂载， 在 componentWillUnmount 中清除。</li>
<li>最好不要将 react 事件和原生的事件共用，react 是无力阻止原生事件的冒泡的。而在原生事件里阻止冒泡，是可以阻止 react 事件的冒泡的。</li>
</ul>
<h1 id="react-组件抽象"><a href="#react-组件抽象" class="headerlink" title="react 组件抽象"></a>react 组件抽象</h1><ul>
<li>react 的高阶组件思路有两种——属性代理和反向继承。前者是进行一次包裹、后者是继承然后调用目标组件的 render。</li>
<li>两种方法都可以很好的处理 state、props 或者进行渲染劫持。</li>
<li>不过生命周期顺序有不同：前者是 didMount-&gt;HOC did mount -&gt; HOC will unmount -&gt; unmount, 后者是 did mount -&gt; HOC did mount -&gt; will unmount -&gt; HOC will unmout</li>
</ul>
<h1 id="react-性能优化"><a href="#react-性能优化" class="headerlink" title="react 性能优化"></a>react 性能优化</h1><ul>
<li>尽量使用纯函数组件</li>
<li>使用 Immutable，该库使用 tire 进行设计，非常的高效和好用</li>
</ul>
<h1 id="react-源码注意点"><a href="#react-源码注意点" class="headerlink" title="react 源码注意点"></a>react 源码注意点</h1><ul>
<li>react 对于 text、DOM 和 Component 有不同的处理</li>
<li>在处理差异时，基本就是先干掉没有的旧属性，然后加上或修改新属性（包括样式、监听器、属性、DOM 属性）</li>
<li>生命周期的实现是使用模版设计模式，且大量使用的 事务（可嵌套，前后有操作，中间才是任务）</li>
<li>setState 使用事务来进行标记，在同步状态下会将几个更新放入队列中合并、而异步时不会进入事务</li>
<li>diff 算法分为 tree diff 部分、component diff 和 element diff</li>
<li>patch 部分即为将更新映射到 DOM 上</li>
</ul>
<h1 id="MVC-和-MVVM"><a href="#MVC-和-MVVM" class="headerlink" title="MVC 和 MVVM"></a>MVC 和 MVVM</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p><img src="https://crxdoc-zh.appspot.com/static/images/mvc.png" alt="MVC 架构图"></p>
<ul>
<li>Model 负责保存数据以及和后端交互数据或校验数据，Model 的改变会应用到 View 上</li>
<li>View 是 Model 的可视化表示</li>
<li>Controller 负责连接 View 和 Model，View 的操作会通过 Controller 应用到 Model 上</li>
</ul>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><img src="https://ask.qcloudimg.com/http-save/yehe-2192986/uptje5tcky.png?imageView2/2/w/1620" alt="MVVM 架构图"></p>
<ul>
<li>区别就在于用 ViewModel 代替了 Controller，ViewModel 是双向绑定的</li>
</ul>
<h1 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h1><h2 id="三大原则："><a href="#三大原则：" class="headerlink" title="三大原则："></a>三大原则：</h2><ul>
<li>单一数据源</li>
<li>状态是只读的</li>
<li>状态修改由纯函数完成</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li>中间件中使用 dispatch 的原因一般是因为希望不到达原生的分发，通常是在异步流里</li>
<li>webpack.DefinePlugin 可以让我们定义任意字符串，并在代码中把字符串替换成该值（可以用来检测是否为环境变了）</li>
<li>将 router 和 redux 也是很重要的部分</li>
</ul>
<h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><p>现在的渲染方式有以下几种——前端渲染、后端渲染和混合渲染。</p>
<h3 id="前端渲染"><a href="#前端渲染" class="headerlink" title="前端渲染"></a>前端渲染</h3><p>SPA 最正常的渲染方式，也就是绝大多数人所使用的。当完成开发后打包就好。</p>
<h3 id="后端渲染"><a href="#后端渲染" class="headerlink" title="后端渲染"></a>后端渲染</h3><p>纯粹的后端渲染其实很像模版了——都是路由对应后端的某个路径，当请求该路径的时候会把 jsx 当作类似于模版的东西，将获得的数据传入其中，然后在后端完成代码的执行，得到生成的 html 后再发送至浏览器。<br>其实可以将后端渲染理解为一个运行在服务器的简易版浏览器。</p>
<h3 id="混合渲染"><a href="#混合渲染" class="headerlink" title="混合渲染"></a>混合渲染</h3><p>前后端渲染都有所涉及，比较常见的方式是只对主页进行服务端渲染，剩下的部分依旧使用前端渲染（比较正常的做法是对不同的路由组件分开进行打包和懒加载，可以很好的提升性能）。</p>
<p>另一种做法被称为 universal app 或者 isomophic app，这种做法就是对同一个路径前后端都进行支持，当用户以正常的点击进入时，走的是前端路由，而如果在该页面刷新的话，使用的就是后端的服务器端渲染。</p>
<p>要注意的是，当一个组件想要支持服务器端渲染时，需要在获取数据的那部分做一点兼容（若传入数据，则直接使用，否则用 ajax 请求来获取数据）</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://juejin.im/post/5b0269c2518825428b3916f9#comment" target="_blank" rel="noopener">React + Koa 实现服务端渲染(SSR)</a></li>
<li><a href="https://juejin.im/post/5c73ad30f265da2db66de010" target="_blank" rel="noopener">React + Koa 实现服务端渲染(SSR) Part II</a></li>
<li><a href="https://juejin.im/post/5a0536346fb9a044fe45d33a" target="_blank" rel="noopener">服务端渲染与 Universal React App</a></li>
<li><a href="http://www.liuweibo.cn/p/206" target="_blank" rel="noopener">react 服务端(ssr) 框架next.js开发个人网站分享</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/25/redux-undo-机制探索/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/25/redux-undo-机制探索/" itemprop="url">redux-undo 机制探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-25T16:41:49+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在看到 redux 的示例的时候，看到了一个很有意思的项目 —— redux-undo。该项目的作用在于时间旅行，可以很好的进行撤销、重做等操作。我比较好奇它的实现，所以就看了一下代码。代码很简单，但是还是决定要记录一下，一面日后遗忘。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>redux-undo 本质上是一个 redux 的 enhancer，它用两个数组和一个 present 来记录之前的状态和当前的状态，当触发 undo、 redo、 jump 等操作时，就去调用相应的 state，然后直接将其返回。这样就可以跳转到当时的状态。若这个 action 类型是没有见过的，那么直接调用原 reducer。<br>以下是不完整的代码，大致是这个思路：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">export default function undoable (reducer, rawConfig = &#123;&#125;) &#123;</span><br><span class="line"></span><br><span class="line">  let initialState = config.history</span><br><span class="line">  return (state = initialState, action = &#123;&#125;, ...slices) =&gt; &#123;</span><br><span class="line">    debug.start(action, state)</span><br><span class="line"></span><br><span class="line">    let history = state</span><br><span class="line"></span><br><span class="line">    const skipReducer = (res) =&gt; config.neverSkipReducer</span><br><span class="line">      ? &#123;</span><br><span class="line">        ...res,</span><br><span class="line">        present: reducer(res.present, action, ...slices)</span><br><span class="line">      &#125; : res</span><br><span class="line"></span><br><span class="line">    let res</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">      case undefined:</span><br><span class="line">        return history</span><br><span class="line"></span><br><span class="line">      case config.undoType:</span><br><span class="line">        res = jump(history, -1)</span><br><span class="line">        debug.log(&apos;perform undo&apos;)</span><br><span class="line">        debug.end(res)</span><br><span class="line">        return skipReducer(res)</span><br><span class="line"></span><br><span class="line">      case config.redoType:</span><br><span class="line">        res = jump(history, 1)</span><br><span class="line">        debug.log(&apos;perform redo&apos;)</span><br><span class="line">        debug.end(res)</span><br><span class="line">        return skipReducer(res)</span><br><span class="line"></span><br><span class="line">      case config.jumpToPastType:</span><br><span class="line">        res = jumpToPast(history, action.index)</span><br><span class="line">        debug.log(`perform jumpToPast to $&#123;action.index&#125;`)</span><br><span class="line">        debug.end(res)</span><br><span class="line">        return skipReducer(res)</span><br><span class="line"></span><br><span class="line">      case config.jumpToFutureType:</span><br><span class="line">        res = jumpToFuture(history, action.index)</span><br><span class="line">        debug.log(`perform jumpToFuture to $&#123;action.index&#125;`)</span><br><span class="line">        debug.end(res)</span><br><span class="line">        return skipReducer(res)</span><br><span class="line"></span><br><span class="line">      case config.jumpType:</span><br><span class="line">        res = jump(history, action.index)</span><br><span class="line">        debug.log(`perform jump to $&#123;action.index&#125;`)</span><br><span class="line">        debug.end(res)</span><br><span class="line">        return skipReducer(res)</span><br><span class="line"></span><br><span class="line">      case actionTypeAmongClearHistoryType(action.type, config.clearHistoryType):</span><br><span class="line">        res = createHistory(history.present, config.ignoreInitialState)</span><br><span class="line">        debug.log(&apos;perform clearHistory&apos;)</span><br><span class="line">        debug.end(res)</span><br><span class="line">        return skipReducer(res)</span><br><span class="line"></span><br><span class="line">      default:</span><br><span class="line">        res = reducer(</span><br><span class="line">          history.present,</span><br><span class="line">          action,</span><br><span class="line">          ...slices</span><br><span class="line">        )</span><br><span class="line">        return res</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://github.com/omnidan/redux-undo" target="_blank" rel="noopener">redux-undo 仓库</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/25/reselect-机制探索/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/25/reselect-机制探索/" itemprop="url">reselect 机制探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-25T15:10:52+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在学习 redux 的过程中，我看到了一个优化功能非常明显的包 —— reselect.该包的核心作用就是根据输入值进行缓存，若本次输入与上一次输入相同，则不再进行重复计算。<br>本包最常用的地方在于 react-redux 的 mapStateToProps 里面，由于该函数每次 state 更新都会重复计算，无论是否涉及到它。在这种情况下，缓存就显得非常重要了。<br>虽然我个人对 reselect 的猜测是一个闭包，但是还是决定拆开看一看。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createSelector &#125; from &apos;reselect&apos;</span><br><span class="line"></span><br><span class="line">const shopItemsSelector = state =&gt; state.shop.items</span><br><span class="line">const taxPercentSelector = state =&gt; state.shop.taxPercent</span><br><span class="line"></span><br><span class="line">const subtotalSelector = createSelector(</span><br><span class="line">  shopItemsSelector,</span><br><span class="line">  items =&gt; items.reduce((acc, item) =&gt; acc + item.value, 0)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const taxSelector = createSelector(</span><br><span class="line">  subtotalSelector,</span><br><span class="line">  taxPercentSelector,</span><br><span class="line">  (subtotal, taxPercent) =&gt; subtotal * (taxPercent / 100)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export const totalSelector = createSelector(</span><br><span class="line">  subtotalSelector,</span><br><span class="line">  taxSelector,</span><br><span class="line">  (subtotal, tax) =&gt; (&#123; total: subtotal + tax &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">let exampleState = &#123;</span><br><span class="line">  shop: &#123;</span><br><span class="line">    taxPercent: 8,</span><br><span class="line">    items: [</span><br><span class="line">      &#123; name: &apos;apple&apos;, value: 1.20 &#125;,</span><br><span class="line">      &#123; name: &apos;orange&apos;, value: 0.95 &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(subtotalSelector(exampleState)) // 2.15</span><br><span class="line">console.log(taxSelector(exampleState))      // 0.172</span><br><span class="line">console.log(totalSelector(exampleState))    // &#123; total: 2.322 &#125;</span><br></pre></td></tr></table></figure>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="defaultMemoize"><a href="#defaultMemoize" class="headerlink" title="defaultMemoize"></a>defaultMemoize</h2><p>defaultMemoize 是缓存的关键，可以很清楚地看到，就是通过闭包来缓存上一次的输入和结果，然后决定是否重新计算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export function defaultMemoize(func, equalityCheck = defaultEqualityCheck) &#123;</span><br><span class="line">  let lastArgs = null</span><br><span class="line">  let lastResult = null</span><br><span class="line">  // we reference arguments instead of spreading them for performance reasons</span><br><span class="line">  return function () &#123;</span><br><span class="line">    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) &#123;</span><br><span class="line">      // apply arguments instead of spreading for performance.</span><br><span class="line">      lastResult = func.apply(null, arguments)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastArgs = arguments</span><br><span class="line">    return lastResult</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="createSelectorCreator"><a href="#createSelectorCreator" class="headerlink" title="createSelectorCreator"></a>createSelectorCreator</h2><p>createSelectorCreator 则是另一个关键，可以看到，这里的缓存是进行了两层，第一层是 selector 的总输入——一般是全局的 state，第二层则是计算出来的子参数，当两层结果都有不同时，才会触发重新计算。<br>另外，判断是否相等的默认标准是严格相等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">export function createSelectorCreator(memoize, ...memoizeOptions) &#123;</span><br><span class="line">  return (...funcs) =&gt; &#123;</span><br><span class="line">    let recomputations = 0</span><br><span class="line">    const resultFunc = funcs.pop()</span><br><span class="line">    const dependencies = getDependencies(funcs)</span><br><span class="line"></span><br><span class="line">    const memoizedResultFunc = memoize(</span><br><span class="line">      function () &#123;</span><br><span class="line">        recomputations++</span><br><span class="line">        // apply arguments instead of spreading for performance.</span><br><span class="line">        return resultFunc.apply(null, arguments)</span><br><span class="line">      &#125;,</span><br><span class="line">      ...memoizeOptions</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    // If a selector is called with the exact same arguments we don&apos;t need to traverse our dependencies again.</span><br><span class="line">    const selector = memoize(function () &#123;</span><br><span class="line">      const params = []</span><br><span class="line">      const length = dependencies.length</span><br><span class="line"></span><br><span class="line">      for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        // apply arguments instead of spreading and mutate a local list of params for performance.</span><br><span class="line">        params.push(dependencies[i].apply(null, arguments))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // apply arguments instead of spreading for performance.</span><br><span class="line">      return memoizedResultFunc.apply(null, params)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    selector.resultFunc = resultFunc</span><br><span class="line">    selector.dependencies = dependencies</span><br><span class="line">    selector.recomputations = () =&gt; recomputations</span><br><span class="line">    selector.resetRecomputations = () =&gt; recomputations = 0</span><br><span class="line">    return selector</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实东西很有限，但是我还是想记下来，避免以后想不起来。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://github.com/reduxjs/reselect" target="_blank" rel="noopener">reselect 仓库地址</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/24/router-机制探索/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/24/router-机制探索/" itemprop="url">router 机制探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-24T17:31:02+08:00">
                2019-04-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>路由这个概念最先是后端出现的。在以前用模板引擎开发页面时，经常会看到一些 .html 或者 .aspx 结尾的路径，这些就是传统的后端路由, 路由的作用就是根据不同的路径来返回不同的资源（这个资源很多时候是页面）。<br>传统的路由分为以下四步:</p>
<ol>
<li>浏览器发出请求</li>
<li>服务器监听到80端口（或443）有请求过来，并解析url路径</li>
<li>根据服务器的路由配置，返回相应信息（可以是 html 字串，也可以是 json 数据，图片等）</li>
<li>浏览器根据数据包的<code>Content-Type</code>来决定如何解析数据</li>
</ol>
<p>但是后来，前端路由出现了.<br>就算在我接触 SPA 的两年后的今天，我都清楚的记得自己第一次接触前端路由时的震撼和赞叹。将所有的路由跳转都交由前端来负责，确实是里程碑意义的突破，而且，这里面对我来说黑科技的成分实在太重了，所以我决定花一些时间，将里面的东西拆开看一看，了解一下内在的机制。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>所谓前端路由，其实只做了两件事：</p>
<ol>
<li>保证当路径发生变化的时候不会再次向服务器请求数据，也就是避免页面刷新</li>
<li>在路径变化的时候渲染对应的组件</li>
</ol>
<p>甚至第二点都不必要保证——只需要将回调函数和路径对应起来，在路径变为某值时执行对应的回调函数即可。<br>如果要想实现 history 的操作，可以直接使用 html5 的 history，也可以在内部建立一个数组（这样一刷新肯定就没了，但是如果在非 DOM 环境下会很有用）</p>
<p>前端路由常见的实现思路有两种 —— hash 模式和 history 模式。</p>
<h2 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h2><p>hash 模式指的是利用 location.hash 来指定路径，由于 location.hash 的改变不会引起页面的跳转，所以可以很好的完成前端路由的第一点。此外，该模式不需要服务器的配合——向服务器请求的路径只会是根路径，后面的 hash 值是不影响资源的，这样的话如果用户刷新的话，也可以直接跳转到之前的页面。</p>
<p>要注意的是， hash 值的改变是会被直接记录在 history 对象中的，而当我们手动进行前进、后退或手动输入地址的时候只会触发 hashChange 事件(对当前地址的手动输入是不会触发的)，刷新时会触发 load 事件，所以我们只需要监控这两点就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;load&apos;, this.refresh, false);</span><br><span class="line">window.addEventListener(&apos;hashchange&apos;, this.refresh, false);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-73fd628a36c848bce7771c395b9ce6a2_hd.jpg" alt="hash 模式流程图"></p>
<p>总结以下 hash 模式的优点和缺点：<br>优点：</p>
<ul>
<li>兼容性良好</li>
<li>不需要服务器的配合</li>
</ul>
<p>缺点：</p>
<ul>
<li>会有一个丑陋的 # 标志</li>
<li>可能会影响滚动的代码编写</li>
</ul>
<h2 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h2><p>在 html5 中， history.pushState 和 history.replaceState，通过这两个 API 可以改变 url 地址且不会发送请求——这样带来了新的可能。</p>
<p>就像在 hash 模式下我们需要关注 hashchange 事件，在 history 我们需要关注 popstate 事件。</p>
<p>window.onpopstate 是 popstate 事件在 window 对象上的事件处理程序.<br>每当处于激活状态的历史记录条目发生变化时, popstate 事件就会在对应 window 对象上触发. 如果当前处于激活状态的历史记录条目是由 history.pushState() 方法创建,或者由 history.replaceState() 方法修改过的, 则 popstate 事件对象的 state 属性包含了这个历史记录条目的 state 对象的一个拷贝.<br>调用 history.pushState() 或者 history.replaceState() 不会触发 popstate 事件. popstate 事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在 JavaScript 中调用 history.back()、history.forward()、history.go() 方法).</p>
<p>由于我们的 pushState 和 replaceState 方法是不会触发 popstate 事件的，所以我们需要在路由改变的时候手动触发一下。当然，两个事件还是一定要关注的。</p>
<p>当用户手动刷新时，浏览器会向服务器请求资源，而且那个路径在服务器上应当是没有资源的，这种时候服务器应该返回跟路径所对应的资源，然后由前端路由跳到指定页面。</p>
<p><img src="https://pic2.zhimg.com/80/v2-ba9732885bb188f8cde94c24ce5b6757_hd.jpg" alt="history 模式流程图"></p>
<p>优点：</p>
<ul>
<li>没有 # 符号，更为流畅</li>
</ul>
<p>缺点：</p>
<ul>
<li>兼容性问题</li>
<li>需要服务器有所配合</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上，前端路由本质上就是在不刷新页面的情况下改变 url，并对应的有所行动。至于 react-router 或 vue-router 这些，就是要显示在当前路径上的组件了,还是很有意思的。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/25696969" target="_blank" rel="noopener">ReactRouter-V4 构建之道与源码分析</a></li>
<li><a href="https://www.zhihu.com/question/53064386" target="_blank" rel="noopener">前端路由简介</a></li>
<li><a href="https://juejin.im/post/5ac61da66fb9a028c71eae1b" target="_blank" rel="noopener">面试官：你了解前端路由吗</a></li>
<li><a href="https://juejin.im/post/5b31a4f76fb9a00e90018cee" target="_blank" rel="noopener">history与hash路由的区别</a></li>
<li><a href="https://github.com/SME-FE/sme-router" target="_blank" rel="noopener">简易前端路由实现</a></li>
<li><a href="https://github.com/fi3ework/blog/issues/21" target="_blank" rel="noopener">react-router 源码解析</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/22/react-redux-源码解析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/22/react-redux-源码解析/" itemprop="url">react-redux 源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-22T17:46:11+08:00">
                2019-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><p>本次解析的代码是 react-redux 的 v5.0 版本，并不是最新的，不过也很好了。</p>
<p>代码的核心部分是 Provider 和 connectAdvanced 部分，前者是包含全部组件的地方，后者则是传递搞自组件的地方。</p>
<h1 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">export default class Provider extends Component &#123;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    return &#123; store: this.store &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor(props, context) &#123;</span><br><span class="line">    super(props, context)</span><br><span class="line">    this.store = props.store</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return Children.only(this.props.children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">  Provider.prototype.componentWillReceiveProps = function (nextProps) &#123;</span><br><span class="line">    const &#123; store &#125; = this</span><br><span class="line">    const &#123; store: nextStore &#125; = nextProps</span><br><span class="line"></span><br><span class="line">    if (store !== nextStore) &#123;</span><br><span class="line">      warnAboutReceivingStore()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 Provider 基本没做什么事情，就是把 store 放进了 context 里面，以便内部的组件可以直接通过 context 拿到数据。另外比较有意思的地方在于 process.env，这个变量在前端本该是不存在的，但是 webpack 在打包时通过插件将当时的变量注入了进去，也就是说该值是与打包环境有关，而不是与执行环境有关。（可以参考 webpack.config.js）</p>
<h2 id="connnectAdvanced"><a href="#connnectAdvanced" class="headerlink" title="connnectAdvanced"></a>connnectAdvanced</h2><p>本方法会传入一大堆参数，但是这些都属于无关紧要的细节，真正的重点在于它返回的高阶组件，在该组件中，会从 context 中取出 store，此外还会试图取出 parentSub,在最外面的该组件时，就没有这个东西，但是它会把自己放在 context 中，从而让自己内部的 connect 生成的组件可以拿到它。</p>
<p>而在组件的 constructor 中，会执行 initSelector 方法，该方法的作用就是根据 mapStateToProps 和 mapDispatchToProps 来算出新的结果，如果结果和之前不一样，就会将 selector 的 shouldComponentUpdate 字段置为 true。 而用来计算和判断新属性的方法为 run，该方法会在 Connect 组件的 componentDidMount 和 componentWillReceiveProps 以及 subscription.onStateChange 中执行。此外，selector.shouldComponentUpdate 属性会在每次 render 中置为 false。</p>
<p>组件的 constructor 中，还会执行另一个方法 initSubscription，在该方法中，会进行 subscription.onStateChange 的实现（模版设计模式），然后若 selector.shouldComponentUpdate 为 false，则执行子订阅的通知，若为 true， 则更新自己的 state —— 这样会触发整体的更新。</p>
<p>在 Subscription 的实现中，会分为存在 parentSub（Connect 内部中的 Connect）和不存在 parentSub 两种情况。前者会在其父 Subscription 上实现订阅，后者则直接使用 store 的订阅。这样，可以保证子组件的 onStateChange 必然在父组件的之后调用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>代码的核心思路就是这样了，没什么太了不起的地方，但是整体思路还是很巧妙的（个人觉得最巧妙的地方在于优化逻辑以及模版模式上）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">diaotai</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">diaotai</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
