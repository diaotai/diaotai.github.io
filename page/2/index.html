<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="日拱一卒">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="日拱一卒">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="日拱一卒">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>日拱一卒</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">日拱一卒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我将继续前行，不管是前路是荆棘还是坦途</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/09/编码-url-和-base64/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/09/编码-url-和-base64/" itemprop="url">编码: url 和 base64</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-09T20:04:53+08:00">
                2019-06-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>今天突然想到一个问题，为什么需要 url 编码 和 base64 编码呢？如果不做处理会有什么问题呢？</p>
</blockquote>
<h1 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h1><p>在日常生活中文本通常是用 ASCII 表示，而 ASCII 编码的是使用 7 bit 来表示的，大多数些操作系统上则会使用字节 8bit 来存储二进制数据，这样直接使用 ASCII 就可能会出问题。</p>
<p>而标准 base64 共 6 位，即共有 64 个字符（英文大小写、数字和+、/），通过将 3 个 ASCII 字符转化为 4 个 base64 字符，就可以保证规避那些可能出错的 ASCII。转化后的 base64 长度必然能被 4 整除（不算等号）</p>
<p>显然，不是所有文本长度都是 3 的整数倍，因此，当不能被 3 整除时，就用 \0 补齐, 有几个 \0 就有几个 =。</p>
<h1 id="URL-编码"><a href="#URL-编码" class="headerlink" title="URL 编码"></a>URL 编码</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>URL 中通过 &amp; 分隔参数，通过 = 来分隔 key 和 value，但是存在一个问题，如果 key 或者 value 中存在 &amp; 和 = 应当如何处理呢？<br>答案就是通过编码保证这些值避免这些问题，这些需要编码的字符即为不安全字符。</p>
<ul>
<li>空格：Url在传输的过程，或者用户在排版的过程，或者文本处理程序在处理Url的过程，都有可能引入无关紧要的空格，或者将那些有意义的空格给去掉。</li>
<li>引号以及&lt;&gt;：引号和尖括号通常用于在普通文本中起到分隔Url的作用</li>
<li>#：通常用于表示书签或者锚点</li>
<li>%：百分号本身用作对不安全字符进行编码时使用的特殊字符，因此本身需要编码</li>
<li>{}|\^[]`~：某一些网关或者传输代理会篡改这些字符</li>
</ul>
<p>Url编码默认使用的字符集是US-ASCII。例如a在US-ASCII码中对应的字节是0x61，那么Url编码之后得到的就是%61，对于非 ASCII 编码，通常使用 Unicode 的 utf-8 来进行编码。</p>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>在 JS 中， encodeURI 和 encodeURIComponent 的安全字符是不同的，分别如下：</p>
<ul>
<li>encodeURI（82个）：!#$&amp;’()*+,/:;=?@-._~0-9a-zA-Z</li>
<li>encodeURIComponent（71个）：!’()*-._~0-9a-zA-Z</li>
</ul>
<p>encodeURI 需要处理整个 URL，因此很多字符不应当处理，而 encodeURIComponent 则是指 key 或者 value。</p>
<p>表单提交的时候每个值都会经过 URL 编码，但是并不是最新标准。</p>
<p>另外，很多HTTP监视工具或者浏览器地址栏等在显示Url的时候会自动将Url进行一次解码（使用UTF-8字符集），这就是为什么当你在Firefox中访问Google搜索中文的时候，地址栏显示的Url包含中文的缘故。但实际上发送给服务端的原始Url还是经过编码的。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/58479085" target="_blank" rel="noopener">为什么要进行URL编码</a></li>
<li><a href="https://www.zhihu.com/question/36306744/answer/71626823" target="_blank" rel="noopener">为什么要使用base64编码</a></li>
<li><a href="https://stackoverflow.com/questions/3538021/why-do-we-use-base64" target="_blank" rel="noopener">Why do we use Base64?</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/09/server-端认证-cookie-session-and-token/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/09/server-端认证-cookie-session-and-token/" itemprop="url">server 端认证:cookie,session and token</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-09T18:33:01+08:00">
                2019-06-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最初的 Web 时代基本只需要阅读信息，所以无所谓身份认证。但是后续很多应用的出现，让身份认证变成了必须要存在的东西。本文简要介绍三个常见的手段:cookie, session 还有 token</p>
<h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p>cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。由于 cookie 在客户端是完全可见且可修改的，因此不适合放一些机密的东西，也不适合把权限认证完全放在这一层来做。<br>此外，cookie 存在着 CORS 问题，即当需要进行跨域时，在前端应当设置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials= true;</span><br></pre></td></tr></table></figure></p>
<p>而在服务器端应当设置以下内容，借此表示后端愿意获得跨域 cookie 内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: a.com //这里需要换成相应的发起请求的域名</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure></p>
<h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p>session 是将必要信息在服务器端存储，以此来辨认客户端身份的做法。<br>session 可能在服务器的内存来存放，也可能在 NOSQL 里集中存放，当存在负载均衡的时候，如何保证每一次访问都可以到指定 session 是一个很严重的问题。</p>
<h1 id="token"><a href="#token" class="headerlink" title="token"></a>token</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>token 是一种无状态的身份认证手段，拥有可扩展、跨设备（更适合移动端）、跨应用、安全的特点。基于 token 的认证流程如下:</p>
<ol>
<li>用户通过用户名和密码发送请求。</li>
<li>程序验证。</li>
<li>程序返回一个签名的token 给客户端。</li>
<li>客户端储存token,并且每次发送请求都携带token。</li>
<li>服务端验证token并返回数据。<br><img src="https://pic1.zhimg.com/80/v2-26d5210a9c95c3a112372a12555118d4_hd.jpg" alt="token 流程图"></li>
</ol>
<p>token 本质上是用时间换空间，通过每次请求都进行校验，来避免使用空间来存储 session。</p>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT(JSON Web Token) 是应用度很广的一种 token 标准，该标准的 token 中会存在三个部分——Header,Payload 和 $Signature，三者之间由 . 分隔。</p>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 是一个 JSON 对象，对象里有一个值为 “JWT” 的 typ 属性，以及 alg 属性，值为 HS256，表明最终使用的加密算法是 HS256。该对象被 Base64 编码。</p>
<h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>Payload 被定义为实体的状态，就像 token 自身附加元数据一样，claim 包含我们想要传输的信息，以及用于服务器验证的信息，一般有 reserved/public/private 三类。<br>其中 Registered claims 指的是官方推荐但是不强制的一些属性，Public claims 属于公共约定的部分，有特定的地方进行注册，Private claims 就是开发者自行约定的，不需要遵循什么。</p>
<h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>$Signature 则是算法计算后的结果，该算法使用两个参数，第一个是 Base64 编码之后的 Header 和 Payload，第二个是服务器的密钥。<br>通过计算 token 里的前两段和 $Signature 是否一致，就可以判断 token 是否被修改，若无修改，则证明着确实是我们下发的 token，应予以通过。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>JWT 只能保证信息不被修改，无法保证不被看到，因此，不应该放一些关键信息在 token 中</li>
<li>token 被窃取的情况是无法避免的，服务器无法判断这一点。</li>
</ul>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>体积小（一串字符串）。因而传输速度快</li>
<li>传输方式多样。可以通过 HTTP 头部（推荐）/URL/POST 参数等方式传输</li>
<li>严谨的结构化。它自身（在 payload 中）就包含了所有与用户相关的验证消息，如用户可访问路由、访问有效期等信息，服务器无需再去连接数据库验证信息的有效性，并且 payload 支持应用定制</li>
<li>支持跨域验证，多应用于单点登录</li>
</ul>
<p><strong>单点登录（Single Sign On）：在多个应用系统中，用户只需登陆一次，就可以访问所有相互信任的应用。</strong></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/27370773" target="_blank" rel="noopener">Server端的认证神器——JWT(一)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/63061864" target="_blank" rel="noopener">彻底理解cookie，session，token</a></li>
<li><a href="https://medium.com/dev-bits/a-guide-for-adding-jwt-token-based-authentication-to-your-single-page-nodejs-applications-c403f7cf04f4" target="_blank" rel="noopener">A guide for adding JWT token-based authentication to your single page Node.js applications</a></li>
<li><a href="https://jwt.io/introduction/" target="_blank" rel="noopener">Introduction to JSON Web Tokens</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/03/linux-常见命令汇总/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/linux-常见命令汇总/" itemprop="url">linux 常见命令汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-03T13:21:59+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="记录日期"><a href="#记录日期" class="headerlink" title="记录日期"></a>记录日期</h1><ul>
<li>date: 获取当前日期</li>
<li>cal: 获取日历</li>
</ul>
<h1 id="记录文件跳转"><a href="#记录文件跳转" class="headerlink" title="记录文件跳转"></a>记录文件跳转</h1><ul>
<li>pwd: 列出当前所在的路径</li>
<li>cd: 更改当前所在目录</li>
<li>ls: 列出系统文件内容</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><ul>
<li>以 .开头的文件名是隐藏文件。这表示 ls 命令不能列出它们。而 ls -a 就可以，而很多配置文件就是以这个形式隐藏在 home 目录下的</li>
<li>文件名和目录名是大小写敏感的</li>
<li>linux 文件名支持空格和标点符号，但标点符号仅允许 ‘.’, ‘-‘ 和下划线，此外，不要在文件名中使用 空格，而是用下划线来替代它。</li>
<li>常见命令选项:<br>  -a    –all    列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。<br>  -d    –directory    通常，如果指定了目录名，ls 命令会列出这个目录中的内容，而不是目录本身。 把这个选项与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。<br>  -F    –classify    这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是 目录名，则会加上一个’/‘字符。<br>  -h    –human-readable    当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。<br>  -l        以长格式显示结果。<br>  -r    –reverse    以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。<br>  -S        命令输出结果按照文件大小来排序。<br>  -t        按照修改时间来x排序。<br>  -i  展示文本节点号</li>
</ul>
<h1 id="linux-系统中的目录"><a href="#linux-系统中的目录" class="headerlink" title="linux 系统中的目录"></a>linux 系统中的目录</h1><ul>
<li>/: 根目录</li>
<li>/bin: 包含系统启动和运行所必须的二进制程序</li>
<li>/etc: 所有系统层面的配置文件。也包含一些脚本，这些脚本应在系统启动时运行，其中你每个文件都应该是可读的文件</li>
<li>/home: 系统给每个用户分配一个目录。普通用户只能在自己的目录下写文件</li>
<li>/lib: 包含核心系统程序所使用的共享库文件</li>
<li>/opt: 这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能安装在系统中的商业软件产品</li>
<li>/tmp: 这个/tmp 目录，是用来存储由各种程序创建的临时文件的地方。一些配置导致系统每次 重新启动时，都会清空这个目录</li>
<li>/usr: 在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件</li>
<li>/usr/local: 这个/usr/local 目录，是非系统发行版自带程序的安装目录。 通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中会存在这个目录， 并且在管理员安装程序之前，这个目录是空的。</li>
<li>/var: 除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录存放的是动态文件。各种数据库，假脱机文件， 用户邮件等等，都位于在这里。</li>
</ul>
<h1 id="文件链接"><a href="#文件链接" class="headerlink" title="文件链接"></a>文件链接</h1><ul>
<li>ln file link(ln -s file link)<h2 id="硬连接"><a href="#硬连接" class="headerlink" title="硬连接"></a>硬连接</h2>最初的链接方式，直接连接一个文件，会导致 ls -l 时的连接数增加，不能跨文件系统、不能关联目录<h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2>多个文件名指向的实际是同一个文件，该方法可以很好的管理一些文件的版本问题。<br>很好的解决了硬连接的问题，但是如果目标文件被删除，那么会产生坏连接。</li>
</ul>
<h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><ul>
<li>* 匹配任意多个字符（包括零个或一个）</li>
<li>?    匹配任意一个字符（不包括零个）</li>
<li>[characters]    匹配任意一个属于字符集中的字符</li>
<li>[!characters]    匹配任意一个不是字符集中的字符</li>
<li>[[:class:]]    匹配任意一个属于指定字符类中的字符</li>
</ul>
<h2 id="字符类含义"><a href="#字符类含义" class="headerlink" title="字符类含义"></a>字符类含义</h2><ul>
<li>[:alnum:]    匹配任意一个字母或数字</li>
<li>[:alpha:]    匹配任意一个字母</li>
<li>[:digit:]    匹配任意一个数字</li>
<li>[:lower:]    匹配任意一个小写字母</li>
<li>[:upper:]    匹配任意一个大写字母</li>
</ul>
<h1 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h1><ul>
<li>cp — 复制文件和目录</li>
<li>mv — 移动/重命名文件和目录</li>
<li>mkdir — 创建目录</li>
<li>rm — 删除文件和目录</li>
</ul>
<h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><ul>
<li>cp item1 item2   把 item1 复制到 item2</li>
<li>cp item… directionary   复制多个文件到目录下</li>
<li>当出现 cp -r dir1 dir2 时，若存在 dir2，则 dir1 及其内容会出现在 dir2 内，否则会创建一个 dir2，其内容与 dir1 相同</li>
</ul>
<h3 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h3><ul>
<li>-a, –archive    复制文件和目录，以及它们的属性，包括所有权和权限。 通常，副本具有用户所操作文件的默认属性。</li>
<li>-i, –interactive    在重写已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认重写文件。</li>
<li>-r, –recursive    递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者-a 选项）</li>
<li>-u, –update    当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。</li>
<li>-v, –verbose    显示翔实的命令操作信息</li>
</ul>
<h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><ul>
<li>mv item1 item2</li>
<li>mv item… directory</li>
<li>mv dir1 dir2（同样存在 dir2 是否存在的问题）</li>
</ul>
<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><ul>
<li>-i, –interactive    在删除已存在的文件前，提示用户确认信息。 如果不指定这个选项，rm 会默默地删除文件</li>
<li>-r, –recursive    递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。</li>
<li>-f, –force    忽视不存在的文件，不显示提示信息。这选项覆盖了“–interactive”选项。</li>
<li>-v, –verbose    在执行 rm 命令时，显示翔实的操作信息。</li>
</ul>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>命令分为以下四种：</p>
<ol>
<li>是一个可执行程序，就像我们所看到的位于目录/usr/bin 中的文件一样。 这一类程序可以是用诸如 C 和 C++语言写成的程序编译的二进制文件, 也可以是由诸如shell，perl，python，ruby等等脚本语言写成的程序 </li>
<li>是一个内建于 shell 自身的命令。bash 支持若干命令，内部叫做 shell 内部命令 (builtins)。例如，cd 命令，就是一个 shell 内部命令</li>
<li>是一个 shell 函数。这些是小规模的 shell 脚本，它们混合到环境变量中。 在后续的章节里，我们将讨论配置环境变量以及书写 shell 函数。但是现在， 仅仅意识到它们的存在就可以了</li>
<li>是一个命令别名。我们可以定义自己的命令，建立在其它命令之上</li>
</ol>
<h2 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h2><ul>
<li>type   type command 用来分辨该命令是哪种类型</li>
<li>which  判断该命令的来源（只对可执行程序有效）</li>
<li>help   获取文档</li>
<li>–help 用来显示用法信息</li>
<li>alias<ul>
<li>alias name=’string’  用于生成命令的别名</li>
<li>alias 显示目前的 alias</li>
<li>unalias foo 解除某个 alias</li>
</ul>
</li>
</ul>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>首先，我们要明白标准输入、标准输出和错误输出的概念，通常而言，标准输入连接在键盘，输出连接显示器，但这是可以改变的。</p>
<p>我们可以通过一些符号来完成重定向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /usr/bin &gt; ls-output.txt</span><br></pre></td></tr></table></figure></p>
<p>要注意的是， &gt; 会覆盖之前的内容，因此，当我们需要清空某个文件的内容时，可以使用 &gt; a.txt 的方式来解决。而如果我们要做的是跟在后面，那么应当使用 &gt;&gt;。</p>
<p>标准错误重定向使用的符号是 2&gt;, 且必须放在 &gt; 的后面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /bin/usr 2&gt; ls-error.txt</span><br></pre></td></tr></table></figure></p>
<p>&lt; 符号可以使后面的文件内容作为前面命令的输入</p>
<h2 id="管道线"><a href="#管道线" class="headerlink" title="管道线"></a>管道线</h2><p>管道线的符号为 |，其作用是使得前一个命令的结果作为下一个命令的输出。<br>在管道线中，有以下命令经常被使用</p>
<ul>
<li>cat  查看文件的内容（也可以将多个文件的内容归一）</li>
<li>sort 排序</li>
<li>uniq 报道或忽略重复航（使用 -d 时可以看到重复行）</li>
<li>wc   统计文件的行数、字数、字节数，使用 -l 可以只统计行数</li>
<li>grep grep pattern [file…] 所谓 pattern 就是正则</li>
<li>head / tail -n  打印开头或结尾前几行</li>
<li>tee  从 Stdin 读取数据，并同时输出到 Stdout 和文件（保证流不中断）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/bin | tee ls.txt | grep zip</span><br></pre></td></tr></table></figure>
<h1 id="展开符"><a href="#展开符" class="headerlink" title="展开符"></a>展开符</h1><h2 id="花括号展开"><a href="#花括号展开" class="headerlink" title="花括号展开"></a>花括号展开</h2><ul>
<li>{A,B,C} : A,B,C</li>
<li>{1..5} : 从 1 - 5</li>
</ul>
<h2 id="或"><a href="#或" class="headerlink" title="$ 或 `"></a>$ 或 `</h2><p>$(x) 可以让我们把 x 当作变量来读取，也可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file $(ls /usr/bin/* | grep zip)</span><br></pre></td></tr></table></figure></p>
<h2 id="“”"><a href="#“”" class="headerlink" title="“”"></a>“”</h2><p>在双引号中，参数展开、算数表达式展开和命令替换仍然有效（但是禁止花括号展开）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo &quot;$USER $((2+2)) $(cal)&quot;</span><br><span class="line">me 4    February 2008</span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br></pre></td></tr></table></figure></p>
<p>此外，空格不会成为分隔符，只有换行符才会进行分割</p>
<h2 id="‘"><a href="#‘" class="headerlink" title="‘"></a>‘</h2><p>单引号中禁止所有的展开,而转义符也会失去它的含义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ echo text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER</span><br><span class="line">text /home/me/ls-output.txt a b foo 4 me</span><br><span class="line">[me@linuxbox ~]$ echo &quot;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&quot;</span><br><span class="line">text ~/*.txt   &#123;a,b&#125; foo 4 me</span><br><span class="line">[me@linuxbox ~]$ echo &apos;text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&apos;</span><br><span class="line">text ~/*.txt  &#123;a,b&#125; $(echo foo) $((2+2)) $USER</span><br></pre></td></tr></table></figure></p>
<h1 id="命令行常见技巧"><a href="#命令行常见技巧" class="headerlink" title="命令行常见技巧"></a>命令行常见技巧</h1><ul>
<li>ctrl-a : 移动光标到行首</li>
<li>ctrl-e:  移动光标到行尾</li>
<li>ctrl-l:  同 clear</li>
<li>ctrl-k:  剪切从光标位置到行尾的文本</li>
<li>ctrl-u:  剪切从光标位置到行首的文本</li>
<li>ctrl-y:  把剪切环中的文本粘贴到光标位置</li>
<li>ctrl-r:  反向搜索包含该字符串的命令</li>
<li>ctrl-o:  执行历史列表中的当前项，并移到下一个。如果你想要执行历史列表中一系列的命令，这很方便</li>
</ul>
<h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><h2 id="第一个字符含义"><a href="#第一个字符含义" class="headerlink" title="第一个字符含义"></a>第一个字符含义</h2><ul>
<li>- : 一个普通的文件</li>
<li>d : 一个目录</li>
<li>l : 一个 symbol link</li>
<li>c : 一个字符设备文件</li>
<li>b : 一个块设备文件</li>
</ul>
<h2 id="不同权限含义"><a href="#不同权限含义" class="headerlink" title="不同权限含义"></a>不同权限含义</h2><ul>
<li>r    允许打开并读取文件内容    允许列出目录中的内容，前提是目录必须设置了可执行属性（x）</li>
<li>w    允许写入文件内容或截断文件。但是不允许对文件进行重命名或删除，重命名或删除是由目录的属性决定的    允许在目录下新建、删除或重命名文件，前提是目录必须设置了可执行属性（x）</li>
<li>x    允许将文件作为程序来执行，使用脚本语言编写的程序必须设置为可读才能被执行    允许进入目录，例如：cd directory </li>
</ul>
<h2 id="改变文件权限-chmod"><a href="#改变文件权限-chmod" class="headerlink" title="改变文件权限(chmod)"></a>改变文件权限(chmod)</h2><ul>
<li>数字表示法: 从 0 开始，八进制的顺序为 rwx</li>
<li>符号表示法: u:user, g: group, o:others, a:all<ul>
<li>u+r user 增加 r 权限</li>
<li>a-x 所有人减少 x 权限</li>
<li>go=rw g 和 o 权限为读写</li>
</ul>
</li>
<li>默认权限设置: unmask, 使用的是八进制掩码(要注意，从 0 开始，一共四位)，且只对当前 shell 有效</li>
</ul>
<h2 id="更改用户身份"><a href="#更改用户身份" class="headerlink" title="更改用户身份"></a>更改用户身份</h2><ul>
<li>su -l 要求以某用户身份开启窗口，用户为空，则是超管，然后要求输入指定用户的密码</li>
<li>sudo 以另一个用户的身份执行命令，输入自己的密码</li>
</ul>
<h2 id="改变文件所有者和用户-chown"><a href="#改变文件所有者和用户-chown" class="headerlink" title="改变文件所有者和用户(chown)"></a>改变文件所有者和用户(chown)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [owner][:[group]] file...</span><br></pre></td></tr></table></figure>
<ul>
<li>bob    把文件所有者从当前属主更改为用户 bob</li>
<li>bob:users    把文件所有者改为用户 bob，文件用户组改为用户组 users</li>
<li>:admins    把文件用户组改为组 admins，文件所有者不变</li>
<li>bob:    文件所有者改为用户 bob，文件用户组改为用户 bob 登录系统时所属的用户组</li>
</ul>
<h2 id="更改用户密码-passwd"><a href="#更改用户密码-passwd" class="headerlink" title="更改用户密码(passwd)"></a>更改用户密码(passwd)</h2><p>只输入 passwd 可以更改自己的密码，如果有管理员权限，则可以改其他人的</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>当系统启动的时候，内核先把一些它自己的活动初始化为进程，然后运行一个叫做 init 的程序。init， 依次地，再运行一系列的称为 init 脚本的 shell 脚本（位于/etc），它们可以启动所有的系统服务。 其中许多系统服务以守护（daemon）程序的形式实现，守护程序仅在后台运行，没有任何用户接口(User Interface)。 这样，即使我们没有登录系统，至少系统也在忙于执行一些例行事务。</p>
<h2 id="ps-报告当前进程快照，使用-x-可以看全部进程"><a href="#ps-报告当前进程快照，使用-x-可以看全部进程" class="headerlink" title="ps(报告当前进程快照，使用 x 可以看全部进程)"></a>ps(报告当前进程快照，使用 x 可以看全部进程)</h2><ul>
<li>TTY: 控制终端</li>
<li>TIME: 消耗 cpu 时间vim</li>
<li>CMD: 启动命令</li>
<li>STAT: R(运行中或准备运行)、S(睡眠，进程没有运行，在等待事件)、D(不可中断睡眠，等待 IO 事件)、T（已停止）、Z（已终止子进程，但是还没有被父进程清空）、&lt; (高优先级进程)、N（低优先级进程）</li>
</ul>
<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>可以动态的观察系统的状态，以下参数:</p>
<ul>
<li>Load Avg: 等待运行的进程并共享CPU的个数，三个值分别是 60s, 5min, 15min 的平均值</li>
<li>CPUS: us(用户)、sy（系统内核）、ni（低优先级）、ideal（空闲）、wa（等待 IO）</li>
</ul>
<h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><p>在命令之后加 &amp; 即为后台运行<br>如果要终止一个进程，应当使用 ctrl-c,如果只是停止，那么应该用 ctrl-z</p>
<h2 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h2><p>查看当前活跃任务<br>参数以 %n 的形式指出</p>
<ul>
<li>bg 将某个任务转为后台</li>
<li>fg 将某个任务转为前台</li>
</ul>
<h2 id="常用信号"><a href="#常用信号" class="headerlink" title="常用信号"></a>常用信号</h2><ul>
<li>1  HUP   挂起，可以重新进行初始化</li>
<li>2  INT   中断，同 ctrl-c</li>
<li>9  KILL  杀死，内核级的处理，不会给程序收尾的机会</li>
<li>15 TEAM  终止，kill 的默认信号</li>
<li>18 CONT  继续，恢复进程运行</li>
<li>19 STOP  停止，停止运行</li>
<li>3  QUIT  退出</li>
<li>20 TSTP  终端终止，同 ctrl-z</li>
</ul>
<h2 id="killall-杀死全部"><a href="#killall-杀死全部" class="headerlink" title="killall(杀死全部)"></a>killall(杀死全部)</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>pstree: 输出一个树型结构的进程列表(processtree)，这个列表展示了进程间父/子关系</li>
<li>vmstart: 输出一个系统资源使用快照，包括内存，交换分区和磁盘 I/O,后面可跟数字表明更新时间</li>
<li>xload: 一个图形化界面程序，画出系统负载随时间变化的图像</li>
<li>tload: 在终端内画出图像</li>
</ul>
<h1 id="shell-环境"><a href="#shell-环境" class="headerlink" title="shell 环境"></a>shell 环境</h1><p>shell 在环境中存储了两种基本类型的数据，虽然 bash 几乎无法分辨这些数据的类型。 它们是环境变量和 shell 变量。Shell 变量是 bash 存放的少量数据。剩下的都是 环境变量。除了变量，shell 也存储了一些可编程的数据，即别名和 shell 函数。</p>
<h2 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h2><ul>
<li>printenv [变量名]</li>
<li>echo $变量名</li>
<li>alias: 查看所有 alias </li>
</ul>
<h2 id="shell-启动文件"><a href="#shell-启动文件" class="headerlink" title="shell 启动文件"></a>shell 启动文件</h2><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><ul>
<li>/etc/profile    应用于所有用户的全局配置脚本</li>
<li>~/.bash_profile    用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置</li>
<li>~/.bash_login    如果文件 ~/.bash_profile 没有找到，bash 会尝试读取这个脚本</li>
<li>~/.profile    如果文件 ~/.bash_profile 或文件 ~/.bash_login 都没有找到，bash 会试图读取这个文件。 这是基于 Debian 发行版的默认设置，比方说 Ubuntu</li>
</ul>
<h3 id="非登陆"><a href="#非登陆" class="headerlink" title="非登陆"></a>非登陆</h3><ul>
<li>/etc/bash.bashrc    应用于所有用户的全局配置文件。</li>
<li>~/.bashrc    用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置</li>
</ul>
<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">^:       行首第一个非空字符</span><br><span class="line">$:       本行行末</span><br><span class="line">ctrl-f:  向下翻一页</span><br><span class="line">ctrl-b:  向上翻一页</span><br><span class="line">gg:      全文第一行</span><br><span class="line">G:       全文最后一行</span><br><span class="line">ngg:     全文第 n 行</span><br><span class="line">nH:      当前页面第几行</span><br><span class="line">M:       跳转当前页面中间</span><br><span class="line">nL:      跳转当前页面倒数第几行</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(n)dd:      删除以下几行</span><br><span class="line">d$^:        删除光标到行首或行尾</span><br><span class="line">dG:     	从当前行到文件的末尾</span><br><span class="line">d20G:   	从当前行到文件的第20行</span><br><span class="line">J:          合并当前行和下一行</span><br></pre></td></tr></table></figure>
<h2 id="复制粘贴撤销重做"><a href="#复制粘贴撤销重做" class="headerlink" title="复制粘贴撤销重做"></a>复制粘贴撤销重做</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p               粘贴至光标之后</span><br><span class="line">P               粘贴至光标之前</span><br><span class="line">(n)yy           复制到内存中</span><br><span class="line">u               撤销</span><br><span class="line">.               重复上一步操作</span><br></pre></td></tr></table></figure>
<h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:w filename     另存为filename</span><br><span class="line">:n              跳转到第n行</span><br><span class="line">:m,nw filename  第m-n行写入文件</span><br><span class="line">:.,$w filename  当前行到最后一行写入文件</span><br><span class="line">:f              显示当前信息，比如文件共几行，光标在第几行</span><br></pre></td></tr></table></figure>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:/str/          正向搜索</span><br><span class="line">:?str?          逆向搜索</span><br><span class="line">:%s/Line/line/g 替换</span><br></pre></td></tr></table></figure>
<h2 id="打开多个文件"><a href="#打开多个文件" class="headerlink" title="打开多个文件"></a>打开多个文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi file1 file2 file3...   同时开多个</span><br><span class="line">:e file2                  追加打开</span><br><span class="line">:buffers                  查看目前已打开的文件</span><br><span class="line">:buffer n                 切到第 n 个</span><br></pre></td></tr></table></figure>
<h1 id="包管理系统"><a href="#包管理系统" class="headerlink" title="包管理系统"></a>包管理系统</h1><h2 id="大致分类"><a href="#大致分类" class="headerlink" title="大致分类"></a>大致分类</h2><ul>
<li>Debian Style (.deb)    Debian, Ubuntu, Xandros, Linspire</li>
<li>Red Hat Style (.rpm)    Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS</li>
</ul>
<h2 id="查找某个包"><a href="#查找某个包" class="headerlink" title="查找某个包"></a>查找某个包</h2><ul>
<li>Debian    apt-get update; apt-cache search search_string</li>
<li>Red Hat    yum search search_string</li>
</ul>
<h2 id="从资源库安装某个包"><a href="#从资源库安装某个包" class="headerlink" title="从资源库安装某个包"></a>从资源库安装某个包</h2><ul>
<li>Debian    apt-get update; apt-get install package_name</li>
<li>Red Hat    yum install package_name</li>
</ul>
<h2 id="通过软件包文件安装文件"><a href="#通过软件包文件安装文件" class="headerlink" title="通过软件包文件安装文件"></a>通过软件包文件安装文件</h2><ul>
<li>Debian    dpkg –install package_file</li>
<li>Red Hat    rpm -i package_file</li>
</ul>
<h2 id="卸载文件包"><a href="#卸载文件包" class="headerlink" title="卸载文件包"></a>卸载文件包</h2><ul>
<li>Debian    apt-get remove package_name</li>
<li>Red Hat    yum erase package_name</li>
</ul>
<h2 id="更新软件包"><a href="#更新软件包" class="headerlink" title="更新软件包"></a>更新软件包</h2><ul>
<li>Debian    apt-get update; apt-get upgrade</li>
<li>Red Hat    yum update</li>
<li>Debian    dpkg –install package_file</li>
<li>Red Hat    rpm -U package_file</li>
</ul>
<h2 id="查询软件包"><a href="#查询软件包" class="headerlink" title="查询软件包"></a>查询软件包</h2><h3 id="查询列表"><a href="#查询列表" class="headerlink" title="查询列表"></a>查询列表</h3><ul>
<li>Debian    dpkg –list</li>
<li>Red Hat    rpm -qa<h3 id="确认是否安装"><a href="#确认是否安装" class="headerlink" title="确认是否安装"></a>确认是否安装</h3></li>
<li>Debian    dpkg –status package_name</li>
<li>Red Hat    rpm -q package_name<h3 id="确认文件对应的软件包"><a href="#确认文件对应的软件包" class="headerlink" title="确认文件对应的软件包"></a>确认文件对应的软件包</h3></li>
<li>Debian    dpkg –search file_name</li>
<li>Red Hat    rpm -qf file_name</li>
</ul>
<h1 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h1><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>ping 用来确认网络通畅，该命令发送一个特殊的网络数据包，为 ICMP ECHO_REQUEST，大多数服务器都会回复它。</p>
<h2 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h2><p>追踪连接到某服务器的网络跳转</p>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>统计各种各样的网络路由，-r检测内核路由</p>
<h2 id="网络中传输文件"><a href="#网络中传输文件" class="headerlink" title="网络中传输文件"></a>网络中传输文件</h2><h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h3><ul>
<li>ftp 通常是是匿名的，用户名为 anonymous，密码随意</li>
<li>lcd 用于切换本地的路径</li>
<li>get … 获取某文件</li>
<li>bye 退出 ftp<h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3></li>
<li>可用于递归下载，可以下载多个文件</li>
</ul>
<h2 id="与远程主机通信"><a href="#与远程主机通信" class="headerlink" title="与远程主机通信"></a>与远程主机通信</h2><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p>用来进行安全连接<br>OpenSSH 软件包也包含两个程序，它们可以利用 SSH 加密通道在网络间复制文件。第一个，scp（安全复制）被用来复制文件，与熟悉的 cp 程序非常相似。第二个 SSH 文件复制程序是 sftp，顾名思义，它是 ftp 程序的安全替代品。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp remote-sys:document.txt .</span><br></pre></td></tr></table></figure>
<h1 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h1><h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><p>用于在文件数据库中查找数据</p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><ul>
<li>-type d、f、l</li>
<li>-size 判断大小</li>
<li>可以使用逻辑操作符 -and,-or,-not,()（注意转义）</li>
</ul>
<h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>这个 xargs 命令会执行一个有趣的函数。它从标准输入接受输入，并把输入转换为一个特定命令的 参数列表。</p>
<h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><ul>
<li>ls 的加强版</li>
</ul>
<h1 id="压缩和归档"><a href="#压缩和归档" class="headerlink" title="压缩和归档"></a>压缩和归档</h1><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>一种 linux 下非常常见的压缩操作，后缀为 .gz</p>
<ul>
<li>-d  解压缩</li>
<li>-r  递归</li>
</ul>
<h2 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h2><p>类似于 gzip，但是压缩算法不同，舍弃了压缩速度实现了更高层级的压缩，扩展名为 .bz2</p>
<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>tar 是一种归档命令，它有非常多的模式</p>
<ul>
<li>c: creative,创建归档文件</li>
<li>v: 显示操作过程</li>
<li>f: 指定归档后的文件名</li>
<li>g: 以 gzip 进行压缩</li>
<li>t: 列出归档内容</li>
<li>x: 提取相关文件</li>
<li>p: 保留原文件权限</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf test.tar.gz  test/*    //压缩</span><br><span class="line">tar -ztvf test.tar.gz      // 查看内容</span><br><span class="line">tar -zxvf test.tar.gz       //解压缩</span><br></pre></td></tr></table></figure>
<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>本身既是归档又是压缩，但是用得很少，主要用于和 Windows 交互<br>zip -r ; unzip</p>
<h2 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h2><p>用于远程同步（也可以本地同步，但是至少要有一个在本地）</p>
<h1 id="linux-里的正则"><a href="#linux-里的正则" class="headerlink" title="linux 里的正则"></a>linux 里的正则</h1><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><ul>
<li>i 忽略大小写</li>
<li>v 不匹配</li>
<li>l 输出匹配的文件名，而不是内容</li>
<li>n 打印出对应文件中的行号</li>
</ul>
<h2 id="POSIX-字符集"><a href="#POSIX-字符集" class="headerlink" title="POSIX 字符集"></a>POSIX 字符集</h2><ul>
<li>[:alnum:]    字母数字字符。在 ASCII 中，等价于：[A-Za-z0-9]</li>
<li>[:word:]    与[:alnum:]相同, 但增加了下划线字符。</li>
<li>[:alpha:]    字母字符。在 ASCII 中，等价于：[A-Za-z]</li>
<li>[:blank:]    包含空格和 tab 字符。</li>
<li>[:digit:]    数字0到9</li>
</ul>
<h2 id="BRE"><a href="#BRE" class="headerlink" title="BRE"></a>BRE</h2><p>在 BRE 中，( ) { } ? + | 不被认为是元字符，需要手动转义（grep 和 vim 中都是BRE）<br>find 命令中不是 BRE，也就是说，不需要转义任何东西</p>
<h1 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h1><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>将多个文件连接，-n 显示行号</p>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>对进行排序（默认是每一行）</p>
<ul>
<li>-f: 不区分大小写</li>
<li>-r: 相反顺序</li>
<li>-n: 按照数值排序，而不是字符串值</li>
</ul>
<h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><ul>
<li>-c: 输出所有重复行，并且显示每行重复的次数</li>
<li>-d: 只输出重复行</li>
<li>-u: 只输出独有行，默认</li>
<li>-f n: 忽略每行开头的 n 个字符</li>
</ul>
<h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><p>从文件中抽取一些内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -d &apos;:&apos; -f 1 /etc/passwd | head</span><br></pre></td></tr></table></figure></p>
<ul>
<li>-d: 代表分隔符是什么，默认是单个 tab</li>
<li>-f: 抽取第几段</li>
<li>-c: 抽取定义的 chat_list 文本</li>
</ul>
<h2 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h2><p>将某一列内容插入进去</p>
<h2 id="comm"><a href="#comm" class="headerlink" title="comm"></a>comm</h2><p>comm 命令产生了三列输出。第一列包含第一个文件独有的文本行；第二列， 文本行是第二列独有的；第三列包含两个文件共有的文本行</p>
<ul>
<li>-n: 显示行数</li>
</ul>
<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>diff -u 显示两个文件</p>
<ul>
<li>-:        删除行。这一行将会出现在第一个文件中，而不是第二个文件内。</li>
<li>+:        添加行。这一行将会出现在第二个文件内，而不是第一个文件中。</li>
<li>!:        更改行。将会显示某个文本行的两个版本，每个版本会出现在更改组的各自部分。</li>
</ul>
<h2 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h2><p>运行时编辑，用于转换<br>-s 则用于挤压内容，消除连续重复的文本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;lowercase letters&quot; | tr a-z A-Z</span><br><span class="line">LOWERCASE LETTERS</span><br><span class="line"></span><br><span class="line">echo &quot;aaabbbccc&quot; | tr -s ab</span><br><span class="line">abccc</span><br></pre></td></tr></table></figure></p>
<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>用于查找替换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;front&quot; | sed &apos;2s/front/back/&apos; //将第二行的front替换为back</span><br><span class="line">sed -n &apos;/SUSE/p&apos; distros.txt   // 正则进行查找</span><br><span class="line">SUSE         10.2     12/07/2006</span><br><span class="line">SUSE         11.0     06/19/2008</span><br><span class="line">SUSE         10.3     10/04/2007</span><br><span class="line">SUSE         10.1     05/11/2006</span><br><span class="line">sed -n &apos;/SUSE/!p&apos; distros.txt   // 进行否定</span><br></pre></td></tr></table></figure></p>
<h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><h2 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h2><p>打印行号</p>
<h2 id="fold"><a href="#fold" class="headerlink" title="fold"></a>fold</h2><p>限制文件列宽 -w 指定参数</p>
<h1 id="编译软件"><a href="#编译软件" class="headerlink" title="编译软件"></a>编译软件</h1><h2 id="configure"><a href="#configure" class="headerlink" title="./configure"></a>./configure</h2><p>这个 configure 程序是一个 shell 脚本，由源码树提供。它的工作是分析程序构建环境。大多数源码会设计为可移植的。 也就是说，它被设计成能够在不止一种类 Unix 系统中进行构建。但是为了做到这一点，在建立程序期间，为了适应系统之间的差异， 源码可能需要经过轻微的调整。configure 也会检查是否安装了必要的外部工具和组件。让我们运行 configure 命令。 因为 configure 命令所在的位置不是位于 shell 通常期望程序所呆的地方，我们必须明确地告诉 shell 它的位置，通过 在命令之前加上 ./ 字符，来表明程序位于当前工作目录.<br>我们看到在我们的源码目录中 configure 命令创建了几个新文件。最重要一个是 Makefile。Makefile 是一个配置文件， 指示 make 程序究竟如何构建程序。没有它，make 程序就不能运行。Makefile 是一个普通文本文件，所以我们能查看它：</p>
<h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>make 命令会执行 Makefile 文件，make 命令会保证目标文件是最新的，目标文件必然会新于依赖文件</p>
<h2 id="make-install"><a href="#make-install" class="headerlink" title="make install"></a>make install</h2><p>打包良好的源码经常包括一个特别的 make 目标文件，叫做 install。这个目标文件将在系统目录中安装最终的产品，以供使用。 通常，这个目录是 /usr/local/bin，为在本地所构建软件的传统安装位置。然而，通常普通用户不能写入该目录，所以我们必须变成超级用户， 来执行安装操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p>
<h1 id="编写-bash-脚本"><a href="#编写-bash-脚本" class="headerlink" title="编写 bash 脚本"></a>编写 bash 脚本</h1><h2 id="变量和常量声明"><a href="#变量和常量声明" class="headerlink" title="变量和常量声明"></a>变量和常量声明</h2><ul>
<li>变量: title=”bac”  // 要注意中间不能有空格</li>
<li>title1 = ${title}1 //这样可以局部使用变量</li>
<li>常量: declare -r TITLE=”Page Title” // 习惯上将常量名大写<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function name &#123;</span><br><span class="line">    commands</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name () &#123;</span><br><span class="line">    commands</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>local foo</p>
<h2 id="流程控制之条件"><a href="#流程控制之条件" class="headerlink" title="流程控制之条件"></a>流程控制之条件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if commands; then</span><br><span class="line">     commands</span><br><span class="line">[elif commands; then</span><br><span class="line">     commands...]</span><br><span class="line">[else</span><br><span class="line">     commands]</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>一个简单的 bash 脚本如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># test-string: evaluate the value of a string</span><br><span class="line">ANSWER=maybe</span><br><span class="line">if [ -z &quot;$ANSWER&quot; ]; then</span><br><span class="line">    echo &quot;There is no answer.&quot; &gt;&amp;2</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$ANSWER&quot; = &quot;yes&quot; ]; then</span><br><span class="line">    echo &quot;The answer is YES.&quot;</span><br><span class="line">elif [ &quot;$ANSWER&quot; = &quot;no&quot; ]; then</span><br><span class="line">    echo &quot;The answer is NO.&quot;</span><br><span class="line">elif [ &quot;$ANSWER&quot; = &quot;maybe&quot; ]; then</span><br><span class="line">    echo &quot;The answer is MAYBE.&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;The answer is UNKNOWN.&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>更现代的条件版本是 [[]] 和 (())</p>
<h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><ul>
<li>read variable : 读取某变量</li>
<li>若变量个数少于输入，则多出的都会在最后一个变量上</li>
<li>若只有 read，则全部输入在 REPLY 变量上</li>
<li>变量 IFS 用来说明用什么分隔参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># read-ifs: read fields from a file</span><br><span class="line">FILE=/etc/passwd</span><br><span class="line">read -p &quot;Enter a user name &gt; &quot; user_name</span><br><span class="line">file_info=$(grep &quot;^$user_name:&quot; $FILE)</span><br><span class="line">if [ -n &quot;$file_info&quot; ]; then</span><br><span class="line">    IFS=&quot;:&quot; read user pw uid gid name home shell &lt;&lt;&lt; &quot;$file_info&quot;</span><br><span class="line">    echo &quot;User = &apos;$user&apos;&quot;</span><br><span class="line">    echo &quot;UID = &apos;$uid&apos;&quot;</span><br><span class="line">    echo &quot;GID = &apos;$gid&apos;&quot;</span><br><span class="line">    echo &quot;Full Name = &apos;$name&apos;&quot;</span><br><span class="line">    echo &quot;Home Dir. = &apos;$home&apos;&quot;</span><br><span class="line">    echo &quot;Shell = &apos;$shell&apos;&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;No such user &apos;$user_name&apos;&quot; &gt;&amp;2</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>while commands; do commands; done<br>break 和 continue 一样可用<br>until 和 while 类似，除了条件相反</p>
<h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><p>就是 switch 匹配, ;;&amp; 类似于 switch 的 break<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case word in</span><br><span class="line">    [pattern [| pattern]...) commands ;;]...</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;enter word &gt; &quot;</span><br><span class="line">case $REPLY in</span><br><span class="line">    [[:alpha:]])        echo &quot;is a single alphabetic character.&quot; ;;</span><br><span class="line">    [ABC][0-9])         echo &quot;is A, B, or C followed by a digit.&quot; ;;</span><br><span class="line">    ???)                echo &quot;is three characters long.&quot; ;;</span><br><span class="line">    *.txt)              echo &quot;is a word ending in &apos;.txt&apos;&quot; ;;</span><br><span class="line">    *)                  echo &quot;is something else.&quot; ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<h2 id="访问-bash-脚本参数"><a href="#访问-bash-脚本参数" class="headerlink" title="访问 bash 脚本参数"></a>访问 bash 脚本参数</h2><ul>
<li>$n: 获取第 n 个参数</li>
<li>shift: 所有参数向前移动一位</li>
<li>$0,$*: 拿到所有参数</li>
</ul>
<h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>传统 for 循环是以下的样子,可用使用路径名展开，命令替换或者花括号占考<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for variable [in words]; do</span><br><span class="line">    commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in distros*.txt; do echo $i; done</span><br></pre></td></tr></table></figure>
<p>新 for 循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (( expression1; expression2; expression3 )); do</span><br><span class="line">    commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<h2 id="管理空变量展开"><a href="#管理空变量展开" class="headerlink" title="管理空变量展开"></a>管理空变量展开</h2><h3 id="parameter-word"><a href="#parameter-word" class="headerlink" title="${parameter:-word}"></a>${parameter:-word}</h3><p>本方法为一次性，若 parameter 没有设置（例如，不存在）或者为空，展开结果是 word 的值。若 parameter 不为空，则展开结果是 parameter 的值。</p>
<h3 id="parameter-word-1"><a href="#parameter-word-1" class="headerlink" title="${parameter:=word}"></a>${parameter:=word}</h3><p>可以理解为赋默认值</p>
<h3 id="parameter-word-2"><a href="#parameter-word-2" class="headerlink" title="${parameter:?word}"></a>${parameter:?word}</h3><p>若 parameter 没有设置或为空，这种展开导致脚本带有错误退出，并且 word 的内容会发送到标准错误。若 parameter 不为空， 展开结果是 parameter 的值。</p>
<h3 id="parameter-word-3"><a href="#parameter-word-3" class="headerlink" title="${parameter:+word}"></a>${parameter:+word}</h3><p>若 parameter 没有设置或为空，展开结果为空。若 parameter 不为空， 展开结果是 word 的值会替换掉 parameter 的值；然而，parameter 的值不会改变。</p>
<h2 id="变量名展开"><a href="#变量名展开" class="headerlink" title="变量名展开"></a>变量名展开</h2><p>${!prefix*}、${!prefix@}：列出以 prefix 开头的变量名</p>
<h3 id="查看长度"><a href="#查看长度" class="headerlink" title="查看长度"></a>查看长度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#parameter&#125;</span><br></pre></td></tr></table></figure>
<p>展开成由 parameter 所包含的字符串的长度。通常，parameter 是一个字符串；然而，如果 parameter 是 @ 或者是 * 的话， 则展开结果是位置参数的个数。</p>
<h3 id="parameter-offset-length"><a href="#parameter-offset-length" class="headerlink" title="${parameter:offset:length}"></a>${parameter:offset:length}</h3><p>进行一个截断，length默认是全部，offset若是负值就倒着算</p>
<h3 id="定点清楚"><a href="#定点清楚" class="headerlink" title="定点清楚"></a>定点清楚</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;parameter#pattern&#125;、$&#123;parameter##pattern&#125;、$&#123;parameter%pattern&#125;、$&#123;parameter%%pattern&#125;</span><br></pre></td></tr></table></figure>
<p>进行清除，分别是前面最短、最长，后面</p>
<h2 id="大小写处理"><a href="#大小写处理" class="headerlink" title="大小写处理"></a>大小写处理</h2><h3 id="declare"><a href="#declare" class="headerlink" title="declare"></a>declare</h3><ul>
<li>declare -u upper</li>
<li>declare -l lower<h3 id="大小写展开"><a href="#大小写展开" class="headerlink" title="大小写展开"></a>大小写展开</h3></li>
<li>${parameter,,}    把 parameter 的值全部展开成小写字母。</li>
<li>${parameter,}    仅仅把 parameter 的第一个字符展开成小写字母。</li>
<li>${parameter^^}    把 parameter 的值全部转换成大写字母。</li>
<li>${parameter^}    仅仅把 parameter 的第一个字符转换成大写字母（首字母大写）。</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>创建一个数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[1] = &apos;333&apos;</span><br><span class="line">declare -a a</span><br><span class="line">name=(value1 value2 ...)    // 多赋值</span><br></pre></td></tr></table></figure></p>
<p>${!array[@]}用引号引起来的 @ 格式是最有用的， 因为它能展开成分离的词。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ foo=([2]=a [4]=b [6]=c)</span><br><span class="line">[me@linuxbox ~]$ for i in &quot;$&#123;foo[@]&#125;&quot;; do echo $i; done</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">[me@linuxbox ~]$ for i in &quot;$&#123;!foo[@]&#125;&quot;; do echo $i; done</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p>
<p>在数组末尾追加元素: foo+=(d e f)<br>删除数组使用 unset 命令<br>关联数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare -A colors</span><br><span class="line">colors[&quot;red&quot;]=&quot;#ff0000&quot;</span><br><span class="line">colors[&quot;green&quot;]=&quot;#00ff00&quot;</span><br><span class="line">colors[&quot;blue&quot;]=&quot;#0000ff&quot;</span><br></pre></td></tr></table></figure></p>
<h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><ul>
<li><a href="http://billie66.github.io/TLCL/book/index.html" target="_blank" rel="noopener">bash 教程</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/30/react-总结汇总/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/30/react-总结汇总/" itemprop="url">react 总结汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-30T15:11:41+08:00">
                2019-04-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="react-生命周期"><a href="#react-生命周期" class="headerlink" title="react 生命周期"></a>react 生命周期</h1><p><img src="https://upload-images.jianshu.io/upload_images/4345168-fd3988bc7dcfee69.png" alt="react 生命周期图"></p>
<p>我们可以将 react 生命周期分为两种：当组件在挂载或卸载时和当组件产生实质性更新时。</p>
<p>DOM 真正被添加到 HTML 中的生命周期方法时 componentDidMount 和 componentDidUpdate 中，因此，在这两个方法中去取得 DOM 元素才是有意义的。而取得 DOM 元素的方法有两种，其一是 findDOMNode（只对已挂载组件有作用），其二则是 render 方法中的回调。</p>
<p>在 componentWillReceiveProps 中调用 setState 是很正常的操作，但是经测试，就算不调用，props 的改变也会导致整个子组件的更新。</p>
<h1 id="react-事件机制"><a href="#react-事件机制" class="headerlink" title="react 事件机制"></a>react 事件机制</h1><ul>
<li>react 并不会把时间处理函数直接绑定到真实的节点上，而是把所有时间绑定到结构的最外层，使用一个统一的事件监听器。</li>
<li>在某些情况下我们可能需要使用原生的事件，通常是在 componentDidMount 中挂载， 在 componentWillUnmount 中清除。</li>
<li>最好不要将 react 事件和原生的事件共用，react 是无力阻止原生事件的冒泡的。而在原生事件里阻止冒泡，是可以阻止 react 事件的冒泡的。</li>
</ul>
<h1 id="react-组件抽象"><a href="#react-组件抽象" class="headerlink" title="react 组件抽象"></a>react 组件抽象</h1><ul>
<li>react 的高阶组件思路有两种——属性代理和反向继承。前者是进行一次包裹、后者是继承然后调用目标组件的 render。</li>
<li>两种方法都可以很好的处理 state、props 或者进行渲染劫持。</li>
<li>不过生命周期顺序有不同：前者是 didMount-&gt;HOC did mount -&gt; HOC will unmount -&gt; unmount, 后者是 did mount -&gt; HOC did mount -&gt; will unmount -&gt; HOC will unmout</li>
</ul>
<h1 id="react-性能优化"><a href="#react-性能优化" class="headerlink" title="react 性能优化"></a>react 性能优化</h1><ul>
<li>尽量使用纯函数组件</li>
<li>使用 Immutable，该库使用 tire 进行设计，非常的高效和好用</li>
</ul>
<h1 id="react-源码注意点"><a href="#react-源码注意点" class="headerlink" title="react 源码注意点"></a>react 源码注意点</h1><ul>
<li>react 对于 text、DOM 和 Component 有不同的处理</li>
<li>在处理差异时，基本就是先干掉没有的旧属性，然后加上或修改新属性（包括样式、监听器、属性、DOM 属性）</li>
<li>生命周期的实现是使用模版设计模式，且大量使用的 事务（可嵌套，前后有操作，中间才是任务）</li>
<li>setState 使用事务来进行标记，在同步状态下会将几个更新放入队列中合并、而异步时不会进入事务</li>
<li>diff 算法分为 tree diff 部分、component diff 和 element diff</li>
<li>patch 部分即为将更新映射到 DOM 上</li>
</ul>
<h1 id="MVC-和-MVVM"><a href="#MVC-和-MVVM" class="headerlink" title="MVC 和 MVVM"></a>MVC 和 MVVM</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p><img src="https://crxdoc-zh.appspot.com/static/images/mvc.png" alt="MVC 架构图"></p>
<ul>
<li>Model 负责保存数据以及和后端交互数据或校验数据，Model 的改变会应用到 View 上</li>
<li>View 是 Model 的可视化表示</li>
<li>Controller 负责连接 View 和 Model，View 的操作会通过 Controller 应用到 Model 上</li>
</ul>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><img src="https://ask.qcloudimg.com/http-save/yehe-2192986/uptje5tcky.png?imageView2/2/w/1620" alt="MVVM 架构图"></p>
<ul>
<li>区别就在于用 ViewModel 代替了 Controller，ViewModel 是双向绑定的</li>
</ul>
<h1 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h1><h2 id="三大原则："><a href="#三大原则：" class="headerlink" title="三大原则："></a>三大原则：</h2><ul>
<li>单一数据源</li>
<li>状态是只读的</li>
<li>状态修改由纯函数完成</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li>中间件中使用 dispatch 的原因一般是因为希望不到达原生的分发，通常是在异步流里</li>
<li>webpack.DefinePlugin 可以让我们定义任意字符串，并在代码中把字符串替换成该值（可以用来检测是否为环境变了）</li>
<li>将 router 和 redux 也是很重要的部分</li>
</ul>
<h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><p>现在的渲染方式有以下几种——前端渲染、后端渲染和混合渲染。</p>
<h3 id="前端渲染"><a href="#前端渲染" class="headerlink" title="前端渲染"></a>前端渲染</h3><p>SPA 最正常的渲染方式，也就是绝大多数人所使用的。当完成开发后打包就好。</p>
<h3 id="后端渲染"><a href="#后端渲染" class="headerlink" title="后端渲染"></a>后端渲染</h3><p>纯粹的后端渲染其实很像模版了——都是路由对应后端的某个路径，当请求该路径的时候会把 jsx 当作类似于模版的东西，将获得的数据传入其中，然后在后端完成代码的执行，得到生成的 html 后再发送至浏览器。<br>其实可以将后端渲染理解为一个运行在服务器的简易版浏览器。</p>
<h3 id="混合渲染"><a href="#混合渲染" class="headerlink" title="混合渲染"></a>混合渲染</h3><p>前后端渲染都有所涉及，比较常见的方式是只对主页进行服务端渲染，剩下的部分依旧使用前端渲染（比较正常的做法是对不同的路由组件分开进行打包和懒加载，可以很好的提升性能）。</p>
<p>另一种做法被称为 universal app 或者 isomophic app，这种做法就是对同一个路径前后端都进行支持，当用户以正常的点击进入时，走的是前端路由，而如果在该页面刷新的话，使用的就是后端的服务器端渲染。</p>
<p>要注意的是，当一个组件想要支持服务器端渲染时，需要在获取数据的那部分做一点兼容（若传入数据，则直接使用，否则用 ajax 请求来获取数据）</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://juejin.im/post/5b0269c2518825428b3916f9#comment" target="_blank" rel="noopener">React + Koa 实现服务端渲染(SSR)</a></li>
<li><a href="https://juejin.im/post/5c73ad30f265da2db66de010" target="_blank" rel="noopener">React + Koa 实现服务端渲染(SSR) Part II</a></li>
<li><a href="https://juejin.im/post/5a0536346fb9a044fe45d33a" target="_blank" rel="noopener">服务端渲染与 Universal React App</a></li>
<li><a href="http://www.liuweibo.cn/p/206" target="_blank" rel="noopener">react 服务端(ssr) 框架next.js开发个人网站分享</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/25/redux-undo-机制探索/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/25/redux-undo-机制探索/" itemprop="url">redux-undo 机制探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-25T16:41:49+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在看到 redux 的示例的时候，看到了一个很有意思的项目 —— redux-undo。该项目的作用在于时间旅行，可以很好的进行撤销、重做等操作。我比较好奇它的实现，所以就看了一下代码。代码很简单，但是还是决定要记录一下，一面日后遗忘。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>redux-undo 本质上是一个 redux 的 enhancer，它用两个数组和一个 present 来记录之前的状态和当前的状态，当触发 undo、 redo、 jump 等操作时，就去调用相应的 state，然后直接将其返回。这样就可以跳转到当时的状态。若这个 action 类型是没有见过的，那么直接调用原 reducer。<br>以下是不完整的代码，大致是这个思路：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">export default function undoable (reducer, rawConfig = &#123;&#125;) &#123;</span><br><span class="line"></span><br><span class="line">  let initialState = config.history</span><br><span class="line">  return (state = initialState, action = &#123;&#125;, ...slices) =&gt; &#123;</span><br><span class="line">    debug.start(action, state)</span><br><span class="line"></span><br><span class="line">    let history = state</span><br><span class="line"></span><br><span class="line">    const skipReducer = (res) =&gt; config.neverSkipReducer</span><br><span class="line">      ? &#123;</span><br><span class="line">        ...res,</span><br><span class="line">        present: reducer(res.present, action, ...slices)</span><br><span class="line">      &#125; : res</span><br><span class="line"></span><br><span class="line">    let res</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">      case undefined:</span><br><span class="line">        return history</span><br><span class="line"></span><br><span class="line">      case config.undoType:</span><br><span class="line">        res = jump(history, -1)</span><br><span class="line">        debug.log(&apos;perform undo&apos;)</span><br><span class="line">        debug.end(res)</span><br><span class="line">        return skipReducer(res)</span><br><span class="line"></span><br><span class="line">      case config.redoType:</span><br><span class="line">        res = jump(history, 1)</span><br><span class="line">        debug.log(&apos;perform redo&apos;)</span><br><span class="line">        debug.end(res)</span><br><span class="line">        return skipReducer(res)</span><br><span class="line"></span><br><span class="line">      case config.jumpToPastType:</span><br><span class="line">        res = jumpToPast(history, action.index)</span><br><span class="line">        debug.log(`perform jumpToPast to $&#123;action.index&#125;`)</span><br><span class="line">        debug.end(res)</span><br><span class="line">        return skipReducer(res)</span><br><span class="line"></span><br><span class="line">      case config.jumpToFutureType:</span><br><span class="line">        res = jumpToFuture(history, action.index)</span><br><span class="line">        debug.log(`perform jumpToFuture to $&#123;action.index&#125;`)</span><br><span class="line">        debug.end(res)</span><br><span class="line">        return skipReducer(res)</span><br><span class="line"></span><br><span class="line">      case config.jumpType:</span><br><span class="line">        res = jump(history, action.index)</span><br><span class="line">        debug.log(`perform jump to $&#123;action.index&#125;`)</span><br><span class="line">        debug.end(res)</span><br><span class="line">        return skipReducer(res)</span><br><span class="line"></span><br><span class="line">      case actionTypeAmongClearHistoryType(action.type, config.clearHistoryType):</span><br><span class="line">        res = createHistory(history.present, config.ignoreInitialState)</span><br><span class="line">        debug.log(&apos;perform clearHistory&apos;)</span><br><span class="line">        debug.end(res)</span><br><span class="line">        return skipReducer(res)</span><br><span class="line"></span><br><span class="line">      default:</span><br><span class="line">        res = reducer(</span><br><span class="line">          history.present,</span><br><span class="line">          action,</span><br><span class="line">          ...slices</span><br><span class="line">        )</span><br><span class="line">        return res</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://github.com/omnidan/redux-undo" target="_blank" rel="noopener">redux-undo 仓库</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/25/reselect-机制探索/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/25/reselect-机制探索/" itemprop="url">reselect 机制探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-25T15:10:52+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在学习 redux 的过程中，我看到了一个优化功能非常明显的包 —— reselect.该包的核心作用就是根据输入值进行缓存，若本次输入与上一次输入相同，则不再进行重复计算。<br>本包最常用的地方在于 react-redux 的 mapStateToProps 里面，由于该函数每次 state 更新都会重复计算，无论是否涉及到它。在这种情况下，缓存就显得非常重要了。<br>虽然我个人对 reselect 的猜测是一个闭包，但是还是决定拆开看一看。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createSelector &#125; from &apos;reselect&apos;</span><br><span class="line"></span><br><span class="line">const shopItemsSelector = state =&gt; state.shop.items</span><br><span class="line">const taxPercentSelector = state =&gt; state.shop.taxPercent</span><br><span class="line"></span><br><span class="line">const subtotalSelector = createSelector(</span><br><span class="line">  shopItemsSelector,</span><br><span class="line">  items =&gt; items.reduce((acc, item) =&gt; acc + item.value, 0)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const taxSelector = createSelector(</span><br><span class="line">  subtotalSelector,</span><br><span class="line">  taxPercentSelector,</span><br><span class="line">  (subtotal, taxPercent) =&gt; subtotal * (taxPercent / 100)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export const totalSelector = createSelector(</span><br><span class="line">  subtotalSelector,</span><br><span class="line">  taxSelector,</span><br><span class="line">  (subtotal, tax) =&gt; (&#123; total: subtotal + tax &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">let exampleState = &#123;</span><br><span class="line">  shop: &#123;</span><br><span class="line">    taxPercent: 8,</span><br><span class="line">    items: [</span><br><span class="line">      &#123; name: &apos;apple&apos;, value: 1.20 &#125;,</span><br><span class="line">      &#123; name: &apos;orange&apos;, value: 0.95 &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(subtotalSelector(exampleState)) // 2.15</span><br><span class="line">console.log(taxSelector(exampleState))      // 0.172</span><br><span class="line">console.log(totalSelector(exampleState))    // &#123; total: 2.322 &#125;</span><br></pre></td></tr></table></figure>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="defaultMemoize"><a href="#defaultMemoize" class="headerlink" title="defaultMemoize"></a>defaultMemoize</h2><p>defaultMemoize 是缓存的关键，可以很清楚地看到，就是通过闭包来缓存上一次的输入和结果，然后决定是否重新计算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export function defaultMemoize(func, equalityCheck = defaultEqualityCheck) &#123;</span><br><span class="line">  let lastArgs = null</span><br><span class="line">  let lastResult = null</span><br><span class="line">  // we reference arguments instead of spreading them for performance reasons</span><br><span class="line">  return function () &#123;</span><br><span class="line">    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) &#123;</span><br><span class="line">      // apply arguments instead of spreading for performance.</span><br><span class="line">      lastResult = func.apply(null, arguments)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastArgs = arguments</span><br><span class="line">    return lastResult</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="createSelectorCreator"><a href="#createSelectorCreator" class="headerlink" title="createSelectorCreator"></a>createSelectorCreator</h2><p>createSelectorCreator 则是另一个关键，可以看到，这里的缓存是进行了两层，第一层是 selector 的总输入——一般是全局的 state，第二层则是计算出来的子参数，当两层结果都有不同时，才会触发重新计算。<br>另外，判断是否相等的默认标准是严格相等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">export function createSelectorCreator(memoize, ...memoizeOptions) &#123;</span><br><span class="line">  return (...funcs) =&gt; &#123;</span><br><span class="line">    let recomputations = 0</span><br><span class="line">    const resultFunc = funcs.pop()</span><br><span class="line">    const dependencies = getDependencies(funcs)</span><br><span class="line"></span><br><span class="line">    const memoizedResultFunc = memoize(</span><br><span class="line">      function () &#123;</span><br><span class="line">        recomputations++</span><br><span class="line">        // apply arguments instead of spreading for performance.</span><br><span class="line">        return resultFunc.apply(null, arguments)</span><br><span class="line">      &#125;,</span><br><span class="line">      ...memoizeOptions</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    // If a selector is called with the exact same arguments we don&apos;t need to traverse our dependencies again.</span><br><span class="line">    const selector = memoize(function () &#123;</span><br><span class="line">      const params = []</span><br><span class="line">      const length = dependencies.length</span><br><span class="line"></span><br><span class="line">      for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        // apply arguments instead of spreading and mutate a local list of params for performance.</span><br><span class="line">        params.push(dependencies[i].apply(null, arguments))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // apply arguments instead of spreading for performance.</span><br><span class="line">      return memoizedResultFunc.apply(null, params)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    selector.resultFunc = resultFunc</span><br><span class="line">    selector.dependencies = dependencies</span><br><span class="line">    selector.recomputations = () =&gt; recomputations</span><br><span class="line">    selector.resetRecomputations = () =&gt; recomputations = 0</span><br><span class="line">    return selector</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实东西很有限，但是我还是想记下来，避免以后想不起来。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://github.com/reduxjs/reselect" target="_blank" rel="noopener">reselect 仓库地址</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/24/router-机制探索/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/24/router-机制探索/" itemprop="url">router 机制探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-24T17:31:02+08:00">
                2019-04-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>路由这个概念最先是后端出现的。在以前用模板引擎开发页面时，经常会看到一些 .html 或者 .aspx 结尾的路径，这些就是传统的后端路由, 路由的作用就是根据不同的路径来返回不同的资源（这个资源很多时候是页面）。<br>传统的路由分为以下四步:</p>
<ol>
<li>浏览器发出请求</li>
<li>服务器监听到80端口（或443）有请求过来，并解析url路径</li>
<li>根据服务器的路由配置，返回相应信息（可以是 html 字串，也可以是 json 数据，图片等）</li>
<li>浏览器根据数据包的<code>Content-Type</code>来决定如何解析数据</li>
</ol>
<p>但是后来，前端路由出现了.<br>就算在我接触 SPA 的两年后的今天，我都清楚的记得自己第一次接触前端路由时的震撼和赞叹。将所有的路由跳转都交由前端来负责，确实是里程碑意义的突破，而且，这里面对我来说黑科技的成分实在太重了，所以我决定花一些时间，将里面的东西拆开看一看，了解一下内在的机制。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>所谓前端路由，其实只做了两件事：</p>
<ol>
<li>保证当路径发生变化的时候不会再次向服务器请求数据，也就是避免页面刷新</li>
<li>在路径变化的时候渲染对应的组件</li>
</ol>
<p>甚至第二点都不必要保证——只需要将回调函数和路径对应起来，在路径变为某值时执行对应的回调函数即可。<br>如果要想实现 history 的操作，可以直接使用 html5 的 history，也可以在内部建立一个数组（这样一刷新肯定就没了，但是如果在非 DOM 环境下会很有用）</p>
<p>前端路由常见的实现思路有两种 —— hash 模式和 history 模式。</p>
<h2 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h2><p>hash 模式指的是利用 location.hash 来指定路径，由于 location.hash 的改变不会引起页面的跳转，所以可以很好的完成前端路由的第一点。此外，该模式不需要服务器的配合——向服务器请求的路径只会是根路径，后面的 hash 值是不影响资源的，这样的话如果用户刷新的话，也可以直接跳转到之前的页面。</p>
<p>要注意的是， hash 值的改变是会被直接记录在 history 对象中的，而当我们手动进行前进、后退或手动输入地址的时候只会触发 hashChange 事件(对当前地址的手动输入是不会触发的)，刷新时会触发 load 事件，所以我们只需要监控这两点就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;load&apos;, this.refresh, false);</span><br><span class="line">window.addEventListener(&apos;hashchange&apos;, this.refresh, false);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-73fd628a36c848bce7771c395b9ce6a2_hd.jpg" alt="hash 模式流程图"></p>
<p>总结以下 hash 模式的优点和缺点：<br>优点：</p>
<ul>
<li>兼容性良好</li>
<li>不需要服务器的配合</li>
</ul>
<p>缺点：</p>
<ul>
<li>会有一个丑陋的 # 标志</li>
<li>可能会影响滚动的代码编写</li>
</ul>
<h2 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h2><p>在 html5 中， history.pushState 和 history.replaceState，通过这两个 API 可以改变 url 地址且不会发送请求——这样带来了新的可能。</p>
<p>就像在 hash 模式下我们需要关注 hashchange 事件，在 history 我们需要关注 popstate 事件。</p>
<p>window.onpopstate 是 popstate 事件在 window 对象上的事件处理程序.<br>每当处于激活状态的历史记录条目发生变化时, popstate 事件就会在对应 window 对象上触发. 如果当前处于激活状态的历史记录条目是由 history.pushState() 方法创建,或者由 history.replaceState() 方法修改过的, 则 popstate 事件对象的 state 属性包含了这个历史记录条目的 state 对象的一个拷贝.<br>调用 history.pushState() 或者 history.replaceState() 不会触发 popstate 事件. popstate 事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在 JavaScript 中调用 history.back()、history.forward()、history.go() 方法).</p>
<p>由于我们的 pushState 和 replaceState 方法是不会触发 popstate 事件的，所以我们需要在路由改变的时候手动触发一下。当然，两个事件还是一定要关注的。</p>
<p>当用户手动刷新时，浏览器会向服务器请求资源，而且那个路径在服务器上应当是没有资源的，这种时候服务器应该返回跟路径所对应的资源，然后由前端路由跳到指定页面。</p>
<p><img src="https://pic2.zhimg.com/80/v2-ba9732885bb188f8cde94c24ce5b6757_hd.jpg" alt="history 模式流程图"></p>
<p>优点：</p>
<ul>
<li>没有 # 符号，更为流畅</li>
</ul>
<p>缺点：</p>
<ul>
<li>兼容性问题</li>
<li>需要服务器有所配合</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上，前端路由本质上就是在不刷新页面的情况下改变 url，并对应的有所行动。至于 react-router 或 vue-router 这些，就是要显示在当前路径上的组件了,还是很有意思的。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/25696969" target="_blank" rel="noopener">ReactRouter-V4 构建之道与源码分析</a></li>
<li><a href="https://www.zhihu.com/question/53064386" target="_blank" rel="noopener">前端路由简介</a></li>
<li><a href="https://juejin.im/post/5ac61da66fb9a028c71eae1b" target="_blank" rel="noopener">面试官：你了解前端路由吗</a></li>
<li><a href="https://juejin.im/post/5b31a4f76fb9a00e90018cee" target="_blank" rel="noopener">history与hash路由的区别</a></li>
<li><a href="https://github.com/SME-FE/sme-router" target="_blank" rel="noopener">简易前端路由实现</a></li>
<li><a href="https://github.com/fi3ework/blog/issues/21" target="_blank" rel="noopener">react-router 源码解析</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/22/react-redux-源码解析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/22/react-redux-源码解析/" itemprop="url">react-redux 源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-22T17:46:11+08:00">
                2019-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><p>本次解析的代码是 react-redux 的 v5.0 版本，并不是最新的，不过也很好了。</p>
<p>代码的核心部分是 Provider 和 connectAdvanced 部分，前者是包含全部组件的地方，后者则是传递搞自组件的地方。</p>
<h1 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">export default class Provider extends Component &#123;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    return &#123; store: this.store &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor(props, context) &#123;</span><br><span class="line">    super(props, context)</span><br><span class="line">    this.store = props.store</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return Children.only(this.props.children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">  Provider.prototype.componentWillReceiveProps = function (nextProps) &#123;</span><br><span class="line">    const &#123; store &#125; = this</span><br><span class="line">    const &#123; store: nextStore &#125; = nextProps</span><br><span class="line"></span><br><span class="line">    if (store !== nextStore) &#123;</span><br><span class="line">      warnAboutReceivingStore()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 Provider 基本没做什么事情，就是把 store 放进了 context 里面，以便内部的组件可以直接通过 context 拿到数据。另外比较有意思的地方在于 process.env，这个变量在前端本该是不存在的，但是 webpack 在打包时通过插件将当时的变量注入了进去，也就是说该值是与打包环境有关，而不是与执行环境有关。（可以参考 webpack.config.js）</p>
<h2 id="connnectAdvanced"><a href="#connnectAdvanced" class="headerlink" title="connnectAdvanced"></a>connnectAdvanced</h2><p>本方法会传入一大堆参数，但是这些都属于无关紧要的细节，真正的重点在于它返回的高阶组件，在该组件中，会从 context 中取出 store，此外还会试图取出 parentSub,在最外面的该组件时，就没有这个东西，但是它会把自己放在 context 中，从而让自己内部的 connect 生成的组件可以拿到它。</p>
<p>而在组件的 constructor 中，会执行 initSelector 方法，该方法的作用就是根据 mapStateToProps 和 mapDispatchToProps 来算出新的结果，如果结果和之前不一样，就会将 selector 的 shouldComponentUpdate 字段置为 true。 而用来计算和判断新属性的方法为 run，该方法会在 Connect 组件的 componentDidMount 和 componentWillReceiveProps 以及 subscription.onStateChange 中执行。此外，selector.shouldComponentUpdate 属性会在每次 render 中置为 false。</p>
<p>组件的 constructor 中，还会执行另一个方法 initSubscription，在该方法中，会进行 subscription.onStateChange 的实现（模版设计模式），然后若 selector.shouldComponentUpdate 为 false，则执行子订阅的通知，若为 true， 则更新自己的 state —— 这样会触发整体的更新。</p>
<p>在 Subscription 的实现中，会分为存在 parentSub（Connect 内部中的 Connect）和不存在 parentSub 两种情况。前者会在其父 Subscription 上实现订阅，后者则直接使用 store 的订阅。这样，可以保证子组件的 onStateChange 必然在父组件的之后调用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>代码的核心思路就是这样了，没什么太了不起的地方，但是整体思路还是很巧妙的（个人觉得最巧妙的地方在于优化逻辑以及模版模式上）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/18/react-redux-机制探索/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/18/react-redux-机制探索/" itemprop="url">react-redux 机制探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-18T17:46:06+08:00">
                2019-04-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>react-redux 本身的作用很小，就是为了让 redux 配合 react。其中，暴露出来的接口只有两个—— Provider 组件和 Connect 函数，这两个东西的作用就是将 store 内的数据传入对应组件，传入触发 action 的方法以及在 store 更新时进行更新，要注意的是，react-redux 对于 react 做了一些性能上的优化。</p>
<h1 id="API-简介"><a href="#API-简介" class="headerlink" title="API 简介"></a>API 简介</h1><p>Connect 的两个参数:</p>
<h2 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps"></a>mapStateToProps</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function mapStateToProps(state, ownProps?)</span><br></pre></td></tr></table></figure>
<p>第二个参数是可选的，指的是那些从 Connect 组件上传下来的 prop，没有必要最好别用。<br>该函数的返回值应该是一个对象，其 key 为 this.props.xxx 的名称， value 则是具体值</p>
<h3 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h3><ul>
<li>重塑数据形式（可以改变数据的 key，可以考虑将多个分支的数据合在一起）</li>
<li>使用 selector 来选择数据，本身就是一种很好的避免重复计算的方式（此外， 如果返回值的每一个子对象都没有变化的话，是不会重新渲染的）</li>
<li>运行的逻辑应当尽可能少，因为只要有 dispatch 导致 store 发生变化, 就会触发所有 Connect 包裹组件的重新计算（不管最后是否重新渲染）</li>
<li>应当是同步且不包含副作用，因为这个运算必然会进行很多次，所以任何副作用都可能导致奇怪的错误</li>
<li>该方法使用严格相等(===)来判断子对象是否相等，因此，要注意避免返回 map，concat，… 等方式返回的数据（这样会因为每次引用都不一样导致重新渲染），可以通过 selector 来解决</li>
<li>可以通过将数据运算放在 render 或 reducer 里来减少不必要的运算</li>
<li>该方法在 store 整体无变化的时候不会被执行（因为 redux 里面本身有是否有变化的判断）</li>
</ul>
<h2 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a>mapDispatchToProps</h2><h3 id="空传"><a href="#空传" class="headerlink" title="空传"></a>空传</h3><p>在该值为 null 的时候，组件内部会有一个 dispatch 的属性。而当该值不为空的时候，就不会把 dispatch 传到组件中</p>
<h3 id="函数形式"><a href="#函数形式" class="headerlink" title="函数形式"></a>函数形式</h3><p>一共有 dispatch,ownProps (optional) 两个参数，返回值应当是一个对象，每个 key 都是函数名</p>
<h3 id="对象形式"><a href="#对象形式" class="headerlink" title="对象形式"></a>对象形式</h3><p>key 为函数名， value 为 actionCreator </p>
<h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><p>Provider 是将 store 传入子组件用的，具体的原理就是靠 react 的 context 机制，Provider 会默认创建一个 Context，我们也可以使用自定义的 Context。如果使用自定义的 Context，那么每个 Connect 需要手动传一下。另外是可以存在多个 Context。</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul>
<li>每个 Connect 包裹的组件都是订阅了 store 的</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://react-redux.js.org/using-react-redux/accessing-store" target="_blank" rel="noopener">redux 官方文档</a></li>
<li><a href="https://blog.isquaredsoftware.com/2018/11/react-redux-history-implementation/" target="_blank" rel="noopener">redux 历史和实现</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/16/redux-机制探索/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="diaotai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/16/redux-机制探索/" itemprop="url">redux 机制探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-16T19:53:23+08:00">
                2019-04-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>近日研究了一下 redux 的文档和源码，深感自己原来根本没有理解对 redux 的用法和原理。在花了三天时间把这一块搞明白之后，写下这篇博客作为记录。</p>
<h1 id="什么是-redux"><a href="#什么是-redux" class="headerlink" title="什么是 redux"></a>什么是 redux</h1><p>我一直以为 redux 是一个 react 的专属的全局状态管理工具，但实际上， redux 是一个单向数据流的观察者模式，完全可以用在后端或者其它前端框架里使用。<br>redux 将整个数据流分为以下几个部分:</p>
<h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p>store 是 redux 的核心部分，它负责全局状态的管理（包括创建、更新以及对外暴露）、观察者的管理（包括注册、删除及触发对应的更新）。<br>而全局状态 state 对外是只读的（这也是为什么能保证单向数据流的原因），理论上讲，只要我们有全局 state 的数据，就获得一个 web 状态的复刻。</p>
<p>在 createStore 实现中比较有意思的点包括:</p>
<ul>
<li>通过闭包维持一个变量，保证了不可能在 reducer 中再次触发 action</li>
<li>对 action 的类型判断（原生的 redux 只允许有对象类型的 action）</li>
<li>有一点很搞笑 —— 每次 dispatch 触发会使得所有的 listener 都触发，并没有针对的部分</li>
</ul>
<h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>action 通常而言是对象（当使用 redux-thunk 的时候可以是特定类型的函数）, 这个对象会包含 type 和 data 两部分， 标明了类型和数据。<br>触发 action 是唯一变动 state 的方式, 这也是维持单向数据流的方式</p>
<h2 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h2><p>reducer 可以说是 redux 的核心部分，每一个 reducer 都是一个纯函数（最好是，否则时间旅行就是空谈）。只要我们知道前一个状态和触发的 action，那么必然会算出同一个结果。<br>reducer 的纯函数理论也让 redux 的测试变得非常的容易。</p>
<h2 id="combineReducer"><a href="#combineReducer" class="headerlink" title="combineReducer"></a>combineReducer</h2><p>redux 要求全局只有一个状态，但是这会让我们的开发有很大的麻烦，比如数据更新时的嵌套问题，也不方便 reducer 的测试。<br>而 combinReducer 提供了一个解决方法，它可以把多个 reducer 合并成同一个（返回一个新的 reducer 函数），状态也是如此。<br>不过它的更新机制有点搞笑——它会把所有子 reducer 和传入的 action 都算一遍，由于 reducer 默认返回原状态，所以也没什么大不了的，如果能更新，则必然会更新。</p>
<h2 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h2><p>中间件机制类似于 express 中的中间件，指的是当 dispatch 触发前后进行一些操作，本质上中间件机制就是通过对原 dispatch 进行层层的嵌套调用。</p>
<h1 id="redux-中间件"><a href="#redux-中间件" class="headerlink" title="redux 中间件"></a>redux 中间件</h1><h2 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h2><p>redux-thunk 的本意是用来解决异步问题的，但是实际上可以用来使一个特定类型的函数作为 action。<br>该函数会接受 (dispatch, getState) 作为参数，而在函数中应当触发新的 action，否则父 action 会终结<br>通过这种写法可以把请求数据、更新数据汇成一体，只需要写一个这种类型的函数即可</p>
<h2 id="手写"><a href="#手写" class="headerlink" title="手写"></a>手写</h2><p>中间件只是一个三阶函数， next 可以理解为该中间件内部的中间件们包裹的 dispatch，下面是我手写的一个尝试性的中间件，大致就是这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export function createHelloworld () &#123;</span><br><span class="line">    return (&#123;dispatch, getState&#125;) =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">        console.log(&apos;hello world!!!!!&apos;, action);</span><br><span class="line">        debugger;</span><br><span class="line">        next(action);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const helloWorld = createHelloworld();</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">    helloWorld</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="state-组织"><a href="#state-组织" class="headerlink" title="state 组织"></a>state 组织</h2><p>比较常见的玩法主要是以下几点：</p>
<ul>
<li>将数据像数据库一样组织，准确的说是 selector 机制，这样在一些容易修改数据的web app 中会可靠很多</li>
<li>可以通过 reselect 可以完成对数据很好的缓存（一般写在 mapState 中）, 这样可以避免重复的计算</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://redux.js.org" target="_blank" rel="noopener">redux官网</a></li>
<li><a href="https://blog.isquaredsoftware.com/2017/12/idiomatic-redux-using-reselect-selectors/" target="_blank" rel="noopener">Idiomatic Redux: Using Reselect Selectors for Encapsulation and Performance</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">diaotai</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">diaotai</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
