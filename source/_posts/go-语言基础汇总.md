---
title: go 语言基础汇总
date: 2019-06-17 19:28:04
tags: go
---
# 变量
* 当变量声明时，类型和表达式可以省略一个。如果类型省略，则类型由表达式决定，如果省略表达式，则使用默认空值。
* := 表示声明，若没有该变量，则创建，若存在，则赋值。但是至少要保证创建了一个新变量，否则编译失败
* 指针的值是一个变量的地址。不是所有的值都有地址，但是所有变量都有地址。使用指针可以间接读取或更新变量的值。
* 指针是可以比较的，只有当两个指针指向同一个变量或者两者都是 nil时候，才是相等的
* new(int) 可以直接返回一个新创建的 int 型指针
* 变量将一直生存到它不可访问，其生命周期是通过它是否可达来确定的
* 当创建的局部变量指针被赋值到全局时，即为逃逸，它会被在堆空间分配内存，否则则是栈空间分布。
* 只有类型精确匹配才可以赋值，只有两个值可以赋值时才可以比较
* type 声明定义一个新的类型。当底层类型相同的不同的 type 使用时应当进行类型转化。

# 基本数据
## 数字
* rune 类型是 int32 的同义词，通常使用一个指 Unicode 码点。
* 取模的结果符号只会和被除数一致，整除相除得整数。
* 溢出得情况下会直接舍弃高位
* & 位与操作， | 位或操作， ^ 位异或操作，若为前缀，则为按位取反，&^ 按位清除（z=x&^y,y 某位 为 1，则 z 对应为0， 否则，为 x 的对应位）
* 和 NaN 得比较总是不成立的
* Go 有两种类型的复数，complex64 和 complex128，二者分别由 float32 和 float64组成。
* && 的优先级比 || 更高
## 字符串
* 字符串的第 i 个字节并不代表是第 i 个字符，因为非 ASCII 字符的 UTF-8 码点需要两个或多个字节。
* 字符串的下标越界会引发宕机
* 字符串是不可变的，这也意味着可以在底层共用同一段内存，这使得复制任何长度字符串的开销都很低廉。
* UTF-8 以字节为单位对 Unicode 码点作变长编码。一个文字符号编码的首字节高位指出后面还有多少字节。传统 ASCII 码仅占 1 个字节。变长编码使得字符串无法直接访问第 n 个字符。
* 码点值小于 256 的文字符号可以写成单个16进制的转义形式（\xe4），更高的码点则必须\u.
* len 得到的是字节数，真的要逐个处理 Unicode，则必须使用其他编码机制。比如 UTF-8.
* 字符串属于不可变的，如果需要，则应该使用 bytes.Buffer 对接      
## 常量
* 常量只能是数字、字符串或布尔值（这个常量就是指 const）
* 对常量操作数，所有的数学运算、逻辑运算和比较结果都是常量
* 若同时声明一组常量，除了第一项之外，其余的右侧部分都可以省略，这代表值会复用前面一项的表达式及其类型
* iota 可以从 0 开始递增

# 复合数据类型
* 数组和结构体是值传递，而 slice、map、function、channel 属于引用传递
## 数组
* 数组和结构体都是聚合类型，它们的值由内存中的一组变量组成。数组和结构体的长度都是固定的，slice 和 map 都是动态数据结构，它的长度在元素添加到中可以动态增长
* 数组是具有固定长度且拥有多个类型元素的序列，数组的长度是数组类型的一部分。长度必须是常量，这个表达式需要在程序编译时就可以确定
```
 var a [3]int
 var r [3]int = [3]int{1, 2}  // 初始化一部分
 q:= [...]int{1,2,3}   // 根据给定值确认长度
```
* 如果一个数组的元素类型是可比较的，那么这个数组也是可比较的
* 数组和其它类型都是值传递,也就是说，内部修改无法影响外部，除非通过指针
## slice
* slice 可以理解为可变长度的数组，有三个属性：指针，长度和容量（指针指向原数组第一个元素，长度是元素个数，容器大小是底部数组的长度）
* slice 的元素到过容量则会导致宕机。若 slice 引用超过长度，则最终 slice 要长过原 slice。
* x[m:n]和字符串一样，只消耗常量时间
* 由于 slice 拥有指向数组元素的指针，所以可以在内部修改底层数组的元素
* slice 是不能做比较的，因此也不能做 map 的 key  
* 通常将 append 的调用结果再次赋值给传入 append 函数的 slice
* 
## map
```
ages := make(map[string]int)

ages := map[string]int {
    "abc": 332
}
ages, ok := map[key]
```
* 可以使用 delete(map, key) 的操作来删除值，就算 map 中不存在 key 也没有关系
* map 的地址不可获得，因为 map 的增长可能导致已有元素被重新放置到新的位置
* 大多数 map 操作可以用于 nil map上，但是设置值是不可以的
* 可以通过 ok 来判断 map 中是否存在
* map 唯一的合法结构就是与 nil 比较。
* map 值的类型可以为某些复杂数据结构
## 结构体
```
type Name struct {
    a      int
    b      int
}
P := Name{1, 2}         // 创建一个字面量的方法
P := Name{a:3, b: 4}
```
* 结构体中，成员变量的顺序对于结构体同一性来说很重要，如果顺序改变，那么就算两个不同的结构体
* 结构体成员变量如果首字母大写，那么就算可导出的。一个结构体可以同时包含可导出的成员变量和不可导出的成员变量
* 一个结构体类型不可以包含自身，但是可以包含自身的指针
* 以上两种初始化模式不可混用，此外，无法通过结构体绕过包变量导出机制
* 如果结构体中所有成员变量都可以比较，那么这个结构体就是可以比较的
* 可以通过嵌套匿名结构体的方式来为结构体增加变量，不过初始化的时候必须按照层次来
* 匿名结构体可以轻微绕过包导出机制
* 不能在结构体中放两个变量名相同的变量或匿名结构体

## JSON
```
type Movie struct {
    Title   string
    Year    int `json:"released"
}
```
* 只有可导出的成员变量才可以转换为 json 字段，否则会被无视。在上面的实例中，json 中的 released 字段会被解析成 Year
* 可以在 json 标注中添加 omitempty，这样如果为空则不会被输入到 JSON 中
* JSON 在 unmarshal 阶段是无视大小写的

## 模版
```
{{ .abc }}  // 其中 abc 为变量
通过 {{range .a}} 和 {{end}} 可以处理循环
```
* 通过一系列操作可以得到模版，最后通过 Execute 来得到渲染结果
* template.HTML 会被认为是可靠的值，不会被转义


# 函数
* 函数的类型成为函数签名，当两个函数拥有相同的形参列表和返回列表时，即认为两个函数的类型或签名相同，形参和返回值的名字不影响函数类型
* go 语言中不存在默认参数
* 如果实参中包含引用类型，比如指针、slice、map、函或者通道，那么函数使用形参变量是就有可能会间接地修改是参变量
* go 的栈长度是可变的，最多可达到1GB的上限
* 可以返回多个值，也可以以给返回值命名的方式进行返回值
* 当函数返回非空错误时，其它所有的返回都应该被忽略
* go 使用控制流来处理错误，当有意识的忽略某个错误时，应当以注释的形式给出原因
* 函数可以以变量的形式使用，此外函数不可比较
* 当一个匿名函数需要递归时，必须先声明一个变量然后将匿名函数赋值给这个变量
* 参数列表最后可以以 ... 的形式传递任意树木的参数
* defer 调用会在任何时候执行，具体时间是 defer 结束的时候，defer 没有次数的限制，执行时以 defer 书写的反顺序执行 
* defer 函数可以改变返回值
* 当出现宕机时，正常的程序会停止执行，goroutine 中所有的颜值函数会执行，然后程序会退出并留下一条日志消息
* 通过内置函数 panic 可以进行宕机
* 宕机是可以恢复的，通过 recover 可以恢复，而获得的值就可以拿到 panic 的参数
* init 函数属于普通函数，在每个文件被初始化的时候，会按照声明的顺序自动执行


# 方法
* 一个类型所拥有的方法名所唯一的，不过不同的类型可以使用相同得到方法名
* 方法调用会复制每一个实参变量，如果变量太大或者希望改变该变量，就应该传递指针。如果一个方法是指针，那么习惯上所有的方法都应该是指针
* 不允许为本身是指针的类型进行方法声明
* 编译器会对变量进行隐式的转化，不过只有变量才可以
* 如果所有类型 T 的方法的接收者都是 T（而非对应指针），那么复制它的实例是安全的，调用方法的时候都必须进行一次复制。如果是指针，那么应该尽量避免复制。
* nil 是一个合法的指针值
* 方法的使用顺序是分层的，首先找自己存在的方法，然后是下一级的方法，然后是再下一级。如果同级有同名方法，则会报错
* go 不支持方法的重载
* 通过调用 T.method，可以把方法再一次变成函数，这种情况下第一个值应当是T
* go 支持封装的级别是包而不是类型，同一个包内的代码始终是可见的。

# 接口
* 接口类型是对其它类型行为的概括和抽象。通过使用接口，可以写出更为灵活和通用的函数。对于某一个类型，无需声明它都实现了哪些接口，只需要提供这些声明的方法
* 普通类型指定了所含数据的精确类型及行为，而接口只是指定了行为（也就是说，只知道实现了哪些方法）
* 当一个具体类型要实现某个接口的时候，那么必须实现接口类型中的所有方法
* 接口对于数据类型还是一种封装，变量只能调用接口里暴露的方法
* 可以把接口理解成一种分类方式，分类可以同时有多种标准
* 作为静态类型语言，类型只是编译时概念，因此不是值。给某接口类型赋值与显式转化无异
* 由于编译时无法指导一个接口值的动态类型某所以通过接口来做动态分发。编译器必须生成一段代码从接口拿到方法地址，再间接调用该地址
* 接口是可以比较的，当都为 nil 或者动态类型完全一致且二者动态值相等，那么两个接口值相等（当动态类型一致，但该类型不可比较的时候，则会崩溃）
* 空的接口值和动态类型为 nil 的值不一致，空的接口类型代表什么值都可以接收
* 在处理 sort 接口时，处理指针的代码运行速度会快很多
* 类型断言检查就算确认作为操作数的动态类型是否满足指定的断言类型，当断言类型为具体类型时，若成功，结果就为断言类型为T，失败则崩溃。当断言类型为接口类型时，则检测x的动态类型是否满足T，若成功，不做变更，结果类型变为接口类型 T
* 如果类型断言有两个值，失败也不不会崩溃
* 可以通过接口类型断言来查询特性
* 可以使用接口作为可识别联合类型某操作它的函数经常有 switch，然后对每种类型用于不同的逻辑 

# goroutine 和通道
goroutine 和通道（channel）支持通信顺序进程（CSP）
## goroutine 简介
* 每一个并行执行的活动成为 goroutine。当一个程序启动时，只会有一个 goroutine 来调用 main 函数，称它为 goroutine。新的 goroutine 听过 go 语句进行创建。语法上，一个go 语句是普通的函数或方法调用前加上 go 关键字前缀的，go 语句使得函数在一个新创建的 goroutine 中调用，go 语句本身的执行立即完成。
* 除了从 main 返回或者退出程序之外，没有一个程序化的方法让一个 goroutine 停止另一个，但是可以和 goroutine 通信要求它自己停止。
## 通道
* 每一个通道是一个具体类型的导管，叫作通道的元素类型。一个有 int 类型元素的通道成为 chan int。
* ch := make(chan int)  // 创建一个 int 型通道
* ch <- x 为发送语句， x = -< ch 为接收语句，close 可以关闭通道。关闭通道后的发送操作会导致宕机，在一个已经关闭的通道上进行接受操作将会获取所有已经发送的值，直到通道为空，此时任何接受操作会立即完成。
* make 可以接受第二个参数作为缓冲通道的容量大小。
* 无缓冲通道上的发送操作将会阻塞，直到另一个 goroutine 在对应的通道上执行接受操作，这时值传送完成，两个 goroutine 都可以继续执行。相反，如果接受操作先执行，接收方 goroutine 将阻塞，直到另一个 goroutine 在同一个通道上发送一个值。
* 在并发中， x 早于 y 并不是指发生的时间，而是说这个顺序是可以保证的。同样，x y 并发也不代表同时发生，只是说明不能假设其顺序。
* 并没有直接的方式来判断通道是否已关闭，但是可以通过接受到的通道元素以及 bool 型值来判断通道是否关闭并读完。
* for range 可以在通道上迭代，保证在读完最后一个值后关闭
* 只有需要通知接收方所有数据已发送时才需要关闭通道，通道是根据是否可被访问而被决定是否回收的，而不是根据它是否被关闭。
* 关闭操作只能在发送方 goroutine 上关闭，只能接受的 goroutine 不可被关闭。
* 在参数中， chan<- int 代表只能发送，<-chan int 代表只能接受。在赋值操作后者难过将双向通道转换为单向通道都是允许的，但是反过来是不行的。
* 缓冲通道满时，发送会阻塞，为 0 时，接收会阻塞。
* 无缓冲通道提供强同步保证，因为每一次发送都和一次对景的接收同步，而对于缓冲通道，这些操作是解耦的。
## select 进行多路复用
* select 一致等待，直到一次通信操作（通道上的发送或接收）
* 如果多个情况同时满足， select 随机选择一个，这样保证每一个通道都有相同的机会被选中。
* 如果不希望被 select 阻塞，则可以使用 default。
* 可以通过关闭通道的方式来进行取消（关闭后读取值会立即返回）

# 使用共享变量实现并发
* 如果无法确切的保证一个事件必然优先于另一个事件，那么这两个事件是并发的。如果这个函数在并发调用的情况下依旧能正确工作，那么这个函数是并发安全的。在没有额外同步机制的情况下，从两个或多个 goroutine 同时调用这个函数。
* 数据竞态发生于两个 goroutine 并发读写同一个变量且至少一个是写入的时候。有三种方法可以避免数据竞态：
    * 方法不修改变量。那些从不修改的数据结构以及不可变数据结构本质上就是并发安全的，不需要任何同步
    * 避免通过多个 goroutine 访问同一个变量——通过通道来共享内存
    * 允许多个 goroutine 访问统一变量，但在同一时间只有一个 goroutine 可以访问。该机制被成为互斥机制
## 互斥锁
* 按照惯例，被互斥量保护的变量声明应该紧跟在互斥量之后，如果实际情况不是如此，就要添加注释来说明此事
* lock 和 unlock 之间的代码，可以自由地读取和修改共享变量，这一部分称为临界区域，goroutine 使用完之后应当解锁。
* 当处理并发程序时，应当永远优先考虑清晰度，拒绝过早的优化。在可以使用的地方，就尽量使用 defer 来让临界区域扩展到函数结尾处。
* 当使用一个互斥量的时候，要确保互斥量本身和保护的变量都没有被导出
* 读写互斥锁仅用于在临界区域对共享变量无写操作的情形，一般来讲，我们不应当嘉定那些逻辑上为只读函数或方法不会更新一些变量。
## 内存同步
* 现代计算机一般有多个处理器，每个处理器都有内存的本地缓存。通道通信或互斥锁操作这样的同步原语都会导致处理器把累计的写操作刷回内存并提交。
* 在可能的情况下，把变量局限在单个 goroutine 内部，其他的变量都使用互斥锁保护
* sync.Once 是专门用于解决延迟初始化的特定方案
## goroutine 与线程
* OS 线程的栈大小通常为 2 MB，而 goroutine 的栈不是固定大小的，可以按需增大和缩小
* 因为 OS 线程是由内核来调度，所以控制全县从一个进程到另一个进程需要一个完整的上下文切换：即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。
* 与操作系统的线程调度器不同的是，Go 调度器不是由硬件时钟来定期出发的，而是由特定的 Go 语言结构来触发的。

# 包和管理工具
* 当一个变量并非局部变量时，则对包内的全部文件都可见，如同写在同一个文件里一样。如果名称以大写字母开头，则是导出的，意味着对包外是可见和可访问的。
* 像 ASCII 或 HTML 这样的首字母缩写词会使用相同的大小写
* main 包是很特殊的，该包用于定义一个独立的可运行程序，而不是某个库。在 main 包里，函数 main 也是特殊的。不管在任何函数中， main 做什么事情，总是程序开始执行的地方。当然，main 通常调用其他包中的函数来做更多的事情。
* go 程序编译要快过其他语言，原因如下：
    * 所有导入都在源文件的开头进行显式的列出，这样编译器在确定依赖性时无需处理整个文件
    * 包的依赖性形成有向无环图，因此可以独立甚至并行编译
    * go 包编译输出的目标文件不仅记录自己的导出信息，还会记录锁依赖包的信息。
* 包名通常是导入路径的最后一段，有三个例外：
    * 如果该包定义了一条命令（可执行 Go 程序），那么总使用名称 main。必然会由 go build 生成可执行文件
    * 以 _test.go 结尾文件或者包名中出现_test,该部分用于测试
    * 包名存在版本后缀，则不包括后缀
* 可以在导入路径前改写包名，不过仅替代当前文件
* 按照约定，包名是路径的最后一段。包初始化从声明变量开始，会先解析其依赖的顺序
* 有时需要导入一个包，仅仅为了其副作用：对包级别的变量执行初始化表达式求职，并执行它的 init 函数。例如 import _ "image/png" ，多数情况下，它用来实现一个编译时机制，使用空白引入导入额外的包，从而开启主程序中可选的特性
* 包的命名通常要求简短而无歧义，如果是处理某一个类的包，那么其中的函数就不必要加上这个类名
* pkg 子目录是构建工具存储编译后的包的位置，bin 子目录放置可执行程序。
* go get 创建的目录是远程仓库的真实客户端，而不是仅仅是文件的副本，可以使用版本控制命令来查看本地编辑的差异或更新到不同的版本。
* go get 指定 -u 开关，go get 将确保所有包都更新到到最新版本。如果没有该标记，则本地的包不会更新。
* 通过给目录加一层 vendor 目录，可以保证依赖不更新。
* go build 命令编译每一个命令行参数中的包。如果包是一个库，结果会被舍弃，对于没有编译错误的包几乎不做检查，go build 会在调用命令的当前目录生成可执行程序，可执行程序名取自包的导入路径的最后一段
* 默认情况下，go build 命令构建所有需要的包和它们的依赖性，然后丢弃除了最终可执行程序之外的所有编译后的代码
* go install 和 go build 非常像,区别在于会保存每一个包的编译代码和命令，而不是丢弃。
* go install 和 go build 对于没有改变的包和命令不需要重新编译，从而使后续的构建更加迅速。go build -i 可以将包安装在独立于构建目标的地方。
* 当路径片段中含有 internal 的情况时，即为内部包，内部包只能被 internal 目录的父目录为跟的目录树中的包锁引用

# 测试
* 在 _test.go 文件中，有三种函数需要特殊对待，即功能测试函数、基准测试函数和示例函数。功能测试函数以 Test 开头，用于检测函数的正确性。基准测试函数以 Benchmark 开头，用来测试某些操作的性能， go tests回报操作的平均执行时间。示例函数以 Example 开头，用于提供机器检查过的文档。
* 测试用例是彼此独立的，如果测试表中一个条目造成测试失败，那么其它的条目依旧会测试，这样可以在一次测试用发现多个失败的情况。若需要终止，则使用 t.Fatal 或者 t.Fatalf 函数来终止测试。这些函数的调用必须和 Test 函数在同一个 goroutine 中，而不是在测试创建的其他的 goroutine 中。
* 测试代码和产品代码在一个包李敏。尽管包的名称叫做 main，并且李敏定义了一个 main 函数，但是在测试过程中，该包当作库来测试。
* 白盒测试和黑盒测试的区别即为对包内情况的了解程度。黑盒测试假设测试者对包的了解仅通过公开的 API 和文档美不逻辑是不透明的。而白盒测试可以访问包内部函数和数据结构，并可以做一些改动。
* 外部测试包用于解决循环引用的问题，当包声明为 url_test,它应该单独地编译一个包，这个包仅包含这些文件，然后通过测试。（可以立即为独立的包）
* 应该在测试中只处理你关心的属性，选择性的设置断言，并在错误中输出足够的信息。
* 默认情况下不会运行任何基准测试，当标记 -bench 的参数指定来要运行的基准测试。
* Example 函数的后缀可以将实力函数与他所演示的包或函数项关联。如果只叫 Example 关联，那么就和包 word 相关联。

# 反射
## 基础
* 反射的处理和类型断言有些类似，当我们无法透视一个未知类型的布局时，这段代码就无法继续，这时就需要反射了。
* 反射类型由 reflect 包提供，其中最重要的两个类型是 Type 和 Value。
* reflect.Type 接口只有一个实现，即类型描述符，接口里的动态值也是类型描述符
* reflect.TypeOf 返回一个接口值对应的动态类型，所以它总是返回具体类型（而不是接口类型）
* reflect.ValueOf 函数接受任意的 interface{} 并将接口的动态值以 reflect.Value 的形式返回。
* reflect.Value 和 interface 都可以包含任意的值。二者的区别在于空接口会隐藏值的布局信息、内置操作和相关方法，所以除非我们知道它的动态类型，并用一个断言渗透进去，否则能做的事情就很少了。而 Value 则有很多方法可以用来分析所包含的值。
* relfect 和 Kind 方法可以很好的区分不同的类型
## 坏处
* 反射应当谨慎使用，因为基于反射的代码是很脆弱的。正常情况下编译器可以在编译时报告错误，而反射错误则要等到执行时才以崩溃的方式来报告。
* 反射降低了自动重构和分析工具的安全性和准确度，因为它们无法检测到类型信息。
* 类型本身就是一种文档，大量的使用反射就如同动态语言一样让人难以理解。
* 基于反射的函数会比为特定类型优化的函数要慢一到两个数量级，在关键路径上会大幅降低速度，不过用在测试里是无所谓的事情。 

# 杂
* i++ 是语句而不是表达式，另外，只支持后置而不支持前置
* Go 不允许无意义的临时变量，不然会出现编译错误。
* Go 没有构造或析构函数，没有形参默认值，没有范型
* 一个 ServerMux 可以把多个 http.handler 合成为一个 http.handler
* 在创建预分配空间 map、channel、预分配空间 slice。